<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.20"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>CommonLibs: Common::TVector&lt; T &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">CommonLibs
   &#160;<span id="projectnumber">1.0</span>
   </div>
   <div id="projectbrief">Custom types and utulites created to replace C++ Standard Library in projects, where STL is not allowed</div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.svg"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.20 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('class_common_1_1_t_vector.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="class_common_1_1_t_vector-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">Common::TVector&lt; T &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Container representing array that can change its size.  
 <a href="class_common_1_1_t_vector.html#details">More...</a></p>

<p><code>#include &quot;<a class="el" href="_vector_8h_source.html">CommonTypes/Vector.h</a>&quot;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a519da74235c0cc6e30868e3aaf24f1d9"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_common_1_1_t_vector.html#a519da74235c0cc6e30868e3aaf24f1d9">EReservedCapacityRule</a> : uint8_t { <a class="el" href="class_common_1_1_t_vector.html#a519da74235c0cc6e30868e3aaf24f1d9ac1e19c09f700938f0ff7f1fd4722a3ac">EReservedCapacityRule::Exponential</a>, 
<a class="el" href="class_common_1_1_t_vector.html#a519da74235c0cc6e30868e3aaf24f1d9a32a843da6ea40ab3b17a3421ccdf671b">EReservedCapacityRule::Linear</a>, 
<a class="el" href="class_common_1_1_t_vector.html#a519da74235c0cc6e30868e3aaf24f1d9a661a50974112b2afaa5fc055d89a27de">EReservedCapacityRule::NeverReserve</a>
 }</td></tr>
<tr class="memdesc:a519da74235c0cc6e30868e3aaf24f1d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used to define how methods deal with Capacity.  <a href="class_common_1_1_t_vector.html#a519da74235c0cc6e30868e3aaf24f1d9">More...</a><br /></td></tr>
<tr class="separator:a519da74235c0cc6e30868e3aaf24f1d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a652c25a5143b2494732a42f6cf84c968"><td class="memItemLeft" align="right" valign="top">typedef TIterator&lt; T *, T &amp; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_common_1_1_t_vector.html#a652c25a5143b2494732a42f6cf84c968">CIterator</a></td></tr>
<tr class="memdesc:a652c25a5143b2494732a42f6cf84c968"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterator. Implemented op-s: ++, +=, +, &ndash;, -=, -, ==, !=, =.  <a href="class_common_1_1_t_vector.html#a652c25a5143b2494732a42f6cf84c968">More...</a><br /></td></tr>
<tr class="separator:a652c25a5143b2494732a42f6cf84c968"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0cbcdf3adbfe67697fdf44d86e6f24d"><td class="memItemLeft" align="right" valign="top">typedef TIterator&lt; const T *, const T &amp; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_common_1_1_t_vector.html#ae0cbcdf3adbfe67697fdf44d86e6f24d">CConstIterator</a></td></tr>
<tr class="memdesc:ae0cbcdf3adbfe67697fdf44d86e6f24d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Version of CIterator for const values.  <a href="class_common_1_1_t_vector.html#ae0cbcdf3adbfe67697fdf44d86e6f24d">More...</a><br /></td></tr>
<tr class="separator:ae0cbcdf3adbfe67697fdf44d86e6f24d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc0c21b3e1404bbbc0ea2f4d44020b5d"><td class="memItemLeft" align="right" valign="top">typedef TReverseIterator&lt; T *, T &amp; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_common_1_1_t_vector.html#abc0c21b3e1404bbbc0ea2f4d44020b5d">CReverseIterator</a></td></tr>
<tr class="memdesc:abc0c21b3e1404bbbc0ea2f4d44020b5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reverse iterator. Increment is actually decrement, etc.  <a href="class_common_1_1_t_vector.html#abc0c21b3e1404bbbc0ea2f4d44020b5d">More...</a><br /></td></tr>
<tr class="separator:abc0c21b3e1404bbbc0ea2f4d44020b5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a620ba915fe6601254e82360781ac8cd3"><td class="memItemLeft" align="right" valign="top">typedef TReverseIterator&lt; const T *, const T &amp; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_common_1_1_t_vector.html#a620ba915fe6601254e82360781ac8cd3">CConstReverseIterator</a></td></tr>
<tr class="memdesc:a620ba915fe6601254e82360781ac8cd3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Version of TReverseIterator for const values.  <a href="class_common_1_1_t_vector.html#a620ba915fe6601254e82360781ac8cd3">More...</a><br /></td></tr>
<tr class="separator:a620ba915fe6601254e82360781ac8cd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3a5ce0edf70da5e5d94bbc280f140cb"><td class="memItemLeft" align="right" valign="top">typedef TSafeIterator&lt; T *, T &amp; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_common_1_1_t_vector.html#ab3a5ce0edf70da5e5d94bbc280f140cb">CSafeIterator</a></td></tr>
<tr class="memdesc:ab3a5ce0edf70da5e5d94bbc280f140cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterator that does bounds checking and throws OutOfRange().  <a href="class_common_1_1_t_vector.html#ab3a5ce0edf70da5e5d94bbc280f140cb">More...</a><br /></td></tr>
<tr class="separator:ab3a5ce0edf70da5e5d94bbc280f140cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87927820350f8bc80ac7ad41cc97753a"><td class="memItemLeft" align="right" valign="top">typedef TSafeIterator&lt; const T *, const T &amp; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_common_1_1_t_vector.html#a87927820350f8bc80ac7ad41cc97753a">CSafeConstIterator</a></td></tr>
<tr class="memdesc:a87927820350f8bc80ac7ad41cc97753a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Version of TSafeIterator for const values.  <a href="class_common_1_1_t_vector.html#a87927820350f8bc80ac7ad41cc97753a">More...</a><br /></td></tr>
<tr class="separator:a87927820350f8bc80ac7ad41cc97753a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0344a8c164afdf2d7ba66c07be804f79"><td class="memItemLeft" align="right" valign="top">typedef TSafeReverseIterator&lt; T *, T &amp; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_common_1_1_t_vector.html#a0344a8c164afdf2d7ba66c07be804f79">CSafeReverseIterator</a></td></tr>
<tr class="memdesc:a0344a8c164afdf2d7ba66c07be804f79"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reverse iterator that can throw OutOfRange().  <a href="class_common_1_1_t_vector.html#a0344a8c164afdf2d7ba66c07be804f79">More...</a><br /></td></tr>
<tr class="separator:a0344a8c164afdf2d7ba66c07be804f79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a903eca6362843ebacffd6b63ae85b5db"><td class="memItemLeft" align="right" valign="top">typedef TSafeReverseIterator&lt; const T *, const T &amp; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_common_1_1_t_vector.html#a903eca6362843ebacffd6b63ae85b5db">CSafeConstReverseIterator</a></td></tr>
<tr class="memdesc:a903eca6362843ebacffd6b63ae85b5db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Version of TSafeReverseIterator for const values.  <a href="class_common_1_1_t_vector.html#a903eca6362843ebacffd6b63ae85b5db">More...</a><br /></td></tr>
<tr class="separator:a903eca6362843ebacffd6b63ae85b5db"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a06f65afe586f1ad373215a4a6023f3d9"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_common_1_1_t_vector.html#a06f65afe586f1ad373215a4a6023f3d9">TVector</a> ()=default</td></tr>
<tr class="memdesc:a06f65afe586f1ad373215a4a6023f3d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Empty vector with no heap allocation.  <a href="class_common_1_1_t_vector.html#a06f65afe586f1ad373215a4a6023f3d9">More...</a><br /></td></tr>
<tr class="separator:a06f65afe586f1ad373215a4a6023f3d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a292d1b33a2c92e092e88704a12180ace"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_common_1_1_t_vector.html#a292d1b33a2c92e092e88704a12180ace">TVector</a> (<a class="el" href="class_common_1_1_t_vector.html#a519da74235c0cc6e30868e3aaf24f1d9">EReservedCapacityRule</a> CapacityRule) noexcept</td></tr>
<tr class="memdesc:a292d1b33a2c92e092e88704a12180ace"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates empty vector with Capacity preset predefined.  <a href="class_common_1_1_t_vector.html#a292d1b33a2c92e092e88704a12180ace">More...</a><br /></td></tr>
<tr class="separator:a292d1b33a2c92e092e88704a12180ace"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32fe4c53e91761c2e74d1c60a129e19e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_common_1_1_t_vector.html#a32fe4c53e91761c2e74d1c60a129e19e">TVector</a> (size_t Size, const T &amp;DefaultValue={})</td></tr>
<tr class="memdesc:a32fe4c53e91761c2e74d1c60a129e19e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector with pre-allocated elements.  <a href="class_common_1_1_t_vector.html#a32fe4c53e91761c2e74d1c60a129e19e">More...</a><br /></td></tr>
<tr class="separator:a32fe4c53e91761c2e74d1c60a129e19e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a52533465aeda64aca70875ad397acd"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_common_1_1_t_vector.html#a0a52533465aeda64aca70875ad397acd">TVector</a> (size_t Size, const T *const Array)</td></tr>
<tr class="memdesc:a0a52533465aeda64aca70875ad397acd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector constructed from raw dynamic array (copy).  <a href="class_common_1_1_t_vector.html#a0a52533465aeda64aca70875ad397acd">More...</a><br /></td></tr>
<tr class="separator:a0a52533465aeda64aca70875ad397acd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06352a0489692cda3c97da5e448962c5"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_common_1_1_t_vector.html#a06352a0489692cda3c97da5e448962c5">TVector</a> (const std::initializer_list&lt; T &gt; &amp;ValuesList)</td></tr>
<tr class="memdesc:a06352a0489692cda3c97da5e448962c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Modern C++ initialization syntax: name = {...}.  <a href="class_common_1_1_t_vector.html#a06352a0489692cda3c97da5e448962c5">More...</a><br /></td></tr>
<tr class="separator:a06352a0489692cda3c97da5e448962c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f0b03d7b5296c85fc170e9e1d91f9aa"><td class="memTemplParams" colspan="2">template&lt;typename IteratorType &gt; </td></tr>
<tr class="memitem:a8f0b03d7b5296c85fc170e9e1d91f9aa"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_common_1_1_t_vector.html#a8f0b03d7b5296c85fc170e9e1d91f9aa">TVector</a> (IteratorType <a class="el" href="class_common_1_1_t_vector.html#accd4a771d43b896a745cf2a4f2ff62ea">Begin</a>, IteratorType <a class="el" href="class_common_1_1_t_vector.html#ae6f082451d8a03611bfb5c627155ed31">End</a>, typename std::enable_if&lt;!std::is_integral&lt; IteratorType &gt;::value &gt;::type *=0)</td></tr>
<tr class="memdesc:a8f0b03d7b5296c85fc170e9e1d91f9aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor to get values from another container.  <a href="class_common_1_1_t_vector.html#a8f0b03d7b5296c85fc170e9e1d91f9aa">More...</a><br /></td></tr>
<tr class="separator:a8f0b03d7b5296c85fc170e9e1d91f9aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc1503385b6e91ef3c0b11d9f29ca417"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_common_1_1_t_vector.html#afc1503385b6e91ef3c0b11d9f29ca417">TVector</a> (const <a class="el" href="class_common_1_1_t_vector.html">TVector</a>&lt; T &gt; &amp;Other)</td></tr>
<tr class="memdesc:afc1503385b6e91ef3c0b11d9f29ca417"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize by copying another <a class="el" href="class_common_1_1_t_vector.html" title="Container representing array that can change its size.">TVector</a>.  <a href="class_common_1_1_t_vector.html#afc1503385b6e91ef3c0b11d9f29ca417">More...</a><br /></td></tr>
<tr class="separator:afc1503385b6e91ef3c0b11d9f29ca417"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae80c6e32c6bd2baadc07f46fc7a4fa44"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_common_1_1_t_vector.html#ae80c6e32c6bd2baadc07f46fc7a4fa44">TVector</a> (<a class="el" href="class_common_1_1_t_vector.html">TVector</a>&lt; T &gt; &amp;&amp;Other) noexcept</td></tr>
<tr class="memdesc:ae80c6e32c6bd2baadc07f46fc7a4fa44"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move constructor.  <a href="class_common_1_1_t_vector.html#ae80c6e32c6bd2baadc07f46fc7a4fa44">More...</a><br /></td></tr>
<tr class="separator:ae80c6e32c6bd2baadc07f46fc7a4fa44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41dbc556f69d28bc8c370afa5a4d6f35"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_common_1_1_t_vector.html#a41dbc556f69d28bc8c370afa5a4d6f35">~TVector</a> ()</td></tr>
<tr class="separator:a41dbc556f69d28bc8c370afa5a4d6f35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35241b84a165059df5fb32fc6a4f4aa1"><td class="memTemplParams" colspan="2">template&lt;typename IteratorType &gt; </td></tr>
<tr class="memitem:a35241b84a165059df5fb32fc6a4f4aa1"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_common_1_1_t_vector.html#a35241b84a165059df5fb32fc6a4f4aa1">Assign</a> (IteratorType <a class="el" href="class_common_1_1_t_vector.html#accd4a771d43b896a745cf2a4f2ff62ea">Begin</a>, IteratorType <a class="el" href="class_common_1_1_t_vector.html#ae6f082451d8a03611bfb5c627155ed31">End</a>, bool bAllowAutoShrink=false)</td></tr>
<tr class="memdesc:a35241b84a165059df5fb32fc6a4f4aa1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allows to copy values from another container.  <a href="class_common_1_1_t_vector.html#a35241b84a165059df5fb32fc6a4f4aa1">More...</a><br /></td></tr>
<tr class="separator:a35241b84a165059df5fb32fc6a4f4aa1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3630a743579413731bc45f6f8a05725"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_common_1_1_t_vector.html">TVector</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_common_1_1_t_vector.html#ae3630a743579413731bc45f6f8a05725">operator=</a> (const std::initializer_list&lt; T &gt; &amp;ValuesList)</td></tr>
<tr class="memdesc:ae3630a743579413731bc45f6f8a05725"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allows assignment with = {...} style.  <a href="class_common_1_1_t_vector.html#ae3630a743579413731bc45f6f8a05725">More...</a><br /></td></tr>
<tr class="separator:ae3630a743579413731bc45f6f8a05725"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fad32a50ab9a0c26b41e154d3208485"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_common_1_1_t_vector.html">TVector</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_common_1_1_t_vector.html#a5fad32a50ab9a0c26b41e154d3208485">operator=</a> (const <a class="el" href="class_common_1_1_t_vector.html">TVector</a>&lt; T &gt; &amp;Other)</td></tr>
<tr class="memdesc:a5fad32a50ab9a0c26b41e154d3208485"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assingment operator makes a copy of another vector.  <a href="class_common_1_1_t_vector.html#a5fad32a50ab9a0c26b41e154d3208485">More...</a><br /></td></tr>
<tr class="separator:a5fad32a50ab9a0c26b41e154d3208485"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f809bf06b1b274497beb336b23ecc90"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_common_1_1_t_vector.html">TVector</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_common_1_1_t_vector.html#a3f809bf06b1b274497beb336b23ecc90">operator=</a> (<a class="el" href="class_common_1_1_t_vector.html">TVector</a>&lt; T &gt; &amp;&amp;Other) noexcept</td></tr>
<tr class="memdesc:a3f809bf06b1b274497beb336b23ecc90"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move assignment.  <a href="class_common_1_1_t_vector.html#a3f809bf06b1b274497beb336b23ecc90">More...</a><br /></td></tr>
<tr class="separator:a3f809bf06b1b274497beb336b23ecc90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72d27069bd4c75b8d8c400f50f3f8c1d"><td class="memItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_common_1_1_t_vector.html#a72d27069bd4c75b8d8c400f50f3f8c1d">operator[]</a> (size_t Index)</td></tr>
<tr class="memdesc:a72d27069bd4c75b8d8c400f50f3f8c1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Index operator that prodives access to the element.  <a href="class_common_1_1_t_vector.html#a72d27069bd4c75b8d8c400f50f3f8c1d">More...</a><br /></td></tr>
<tr class="separator:a72d27069bd4c75b8d8c400f50f3f8c1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a998e017cc2ebf5ec5da75ecada4f1768"><td class="memItemLeft" align="right" valign="top">const T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_common_1_1_t_vector.html#a998e017cc2ebf5ec5da75ecada4f1768">operator[]</a> (size_t Index) const</td></tr>
<tr class="memdesc:a998e017cc2ebf5ec5da75ecada4f1768"><td class="mdescLeft">&#160;</td><td class="mdescRight">Index operator for const vectors.  <a href="class_common_1_1_t_vector.html#a998e017cc2ebf5ec5da75ecada4f1768">More...</a><br /></td></tr>
<tr class="separator:a998e017cc2ebf5ec5da75ecada4f1768"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56dc9af2d256198d8df92154adbda4ea"><td class="memItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_common_1_1_t_vector.html#a56dc9af2d256198d8df92154adbda4ea">SafeAt</a> (size_t Index)</td></tr>
<tr class="memdesc:a56dc9af2d256198d8df92154adbda4ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">[] with range check.  <a href="class_common_1_1_t_vector.html#a56dc9af2d256198d8df92154adbda4ea">More...</a><br /></td></tr>
<tr class="separator:a56dc9af2d256198d8df92154adbda4ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a1784efec9a7c23eee1c024c3b73f18"><td class="memItemLeft" align="right" valign="top">const T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_common_1_1_t_vector.html#a0a1784efec9a7c23eee1c024c3b73f18">SafeAt</a> (size_t Index) const</td></tr>
<tr class="separator:a0a1784efec9a7c23eee1c024c3b73f18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e772bfe52d4776ad89cd2e10a032534"><td class="memItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_common_1_1_t_vector.html#a8e772bfe52d4776ad89cd2e10a032534">AutoAt</a> (size_t Index, const T &amp;DefaultValue={})</td></tr>
<tr class="memdesc:a8e772bfe52d4776ad89cd2e10a032534"><td class="mdescLeft">&#160;</td><td class="mdescRight">If element does not exist, this will resize vector and fill newly created elements with provided value.  <a href="class_common_1_1_t_vector.html#a8e772bfe52d4776ad89cd2e10a032534">More...</a><br /></td></tr>
<tr class="separator:a8e772bfe52d4776ad89cd2e10a032534"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefa7ae2e67ba665cbb09f3f100d0a8f2"><td class="memItemLeft" align="right" valign="top">T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_common_1_1_t_vector.html#aefa7ae2e67ba665cbb09f3f100d0a8f2">RawData</a> () noexcept</td></tr>
<tr class="memdesc:aefa7ae2e67ba665cbb09f3f100d0a8f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides access to the internal buffer.  <a href="class_common_1_1_t_vector.html#aefa7ae2e67ba665cbb09f3f100d0a8f2">More...</a><br /></td></tr>
<tr class="separator:aefa7ae2e67ba665cbb09f3f100d0a8f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27b784a5b7c673dcb72593df1efa0564"><td class="memItemLeft" align="right" valign="top">const T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_common_1_1_t_vector.html#a27b784a5b7c673dcb72593df1efa0564">RawData</a> () const noexcept</td></tr>
<tr class="memdesc:a27b784a5b7c673dcb72593df1efa0564"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_common_1_1_t_vector.html#aefa7ae2e67ba665cbb09f3f100d0a8f2" title="Provides access to the internal buffer.">RawData()</a> for const vectors.  <a href="class_common_1_1_t_vector.html#a27b784a5b7c673dcb72593df1efa0564">More...</a><br /></td></tr>
<tr class="separator:a27b784a5b7c673dcb72593df1efa0564"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a948e7a6fcb269ec2fee9ea6f2476ef83"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_common_1_1_t_vector.html#a948e7a6fcb269ec2fee9ea6f2476ef83">operator==</a> (const <a class="el" href="class_common_1_1_t_vector.html">TVector</a>&lt; T &gt; &amp;Other) const noexcept</td></tr>
<tr class="memdesc:a948e7a6fcb269ec2fee9ea6f2476ef83"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if two vectors contain the same values by calling equality operator recursively.  <a href="class_common_1_1_t_vector.html#a948e7a6fcb269ec2fee9ea6f2476ef83">More...</a><br /></td></tr>
<tr class="separator:a948e7a6fcb269ec2fee9ea6f2476ef83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a551eae84407bf7dc0330518e5058978d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_common_1_1_t_vector.html#a551eae84407bf7dc0330518e5058978d">operator!=</a> (const <a class="el" href="class_common_1_1_t_vector.html">TVector</a>&lt; T &gt; &amp;Other) const noexcept</td></tr>
<tr class="memdesc:a551eae84407bf7dc0330518e5058978d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Opposite to operator ==.  <a href="class_common_1_1_t_vector.html#a551eae84407bf7dc0330518e5058978d">More...</a><br /></td></tr>
<tr class="separator:a551eae84407bf7dc0330518e5058978d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7f2d52c3264a6351839beee7d9041dc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_common_1_1_t_vector.html#ab7f2d52c3264a6351839beee7d9041dc">Push</a> (const T &amp;Value)</td></tr>
<tr class="memdesc:ab7f2d52c3264a6351839beee7d9041dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds one element to the end of vector.  <a href="class_common_1_1_t_vector.html#ab7f2d52c3264a6351839beee7d9041dc">More...</a><br /></td></tr>
<tr class="separator:ab7f2d52c3264a6351839beee7d9041dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a024b2f76d062f2ead120fd60c55d7d86"><td class="memTemplParams" colspan="2">template&lt;typename IteratorType &gt; </td></tr>
<tr class="memitem:a024b2f76d062f2ead120fd60c55d7d86"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_common_1_1_t_vector.html#a024b2f76d062f2ead120fd60c55d7d86">Push</a> (IteratorType <a class="el" href="class_common_1_1_t_vector.html#accd4a771d43b896a745cf2a4f2ff62ea">Begin</a>, IteratorType <a class="el" href="class_common_1_1_t_vector.html#ae6f082451d8a03611bfb5c627155ed31">End</a>)</td></tr>
<tr class="memdesc:a024b2f76d062f2ead120fd60c55d7d86"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds elements to the end, uses iterators.  <a href="class_common_1_1_t_vector.html#a024b2f76d062f2ead120fd60c55d7d86">More...</a><br /></td></tr>
<tr class="separator:a024b2f76d062f2ead120fd60c55d7d86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac35a22dbbb3f0c012756936f197e46f0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_common_1_1_t_vector.html#ac35a22dbbb3f0c012756936f197e46f0">Insert</a> (size_t Position, const T &amp;Value=T{}, const T &amp;FillOnResizeWith=T{})</td></tr>
<tr class="memdesc:ac35a22dbbb3f0c012756936f197e46f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts one elements to the specified position.  <a href="class_common_1_1_t_vector.html#ac35a22dbbb3f0c012756936f197e46f0">More...</a><br /></td></tr>
<tr class="separator:ac35a22dbbb3f0c012756936f197e46f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a127c071eb5ab242598cfbf4752327718"><td class="memTemplParams" colspan="2">template&lt;typename IteratorType &gt; </td></tr>
<tr class="memitem:a127c071eb5ab242598cfbf4752327718"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_common_1_1_t_vector.html#a127c071eb5ab242598cfbf4752327718">Insert</a> (size_t Position, IteratorType <a class="el" href="class_common_1_1_t_vector.html#accd4a771d43b896a745cf2a4f2ff62ea">Begin</a>, IteratorType <a class="el" href="class_common_1_1_t_vector.html#ae6f082451d8a03611bfb5c627155ed31">End</a>, const T &amp;FillOnResizeWith=T{}, typename std::enable_if&lt;!std::is_integral&lt; IteratorType &gt;::value &gt;::type *=0)</td></tr>
<tr class="memdesc:a127c071eb5ab242598cfbf4752327718"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts range of elements, starting at Position.  <a href="class_common_1_1_t_vector.html#a127c071eb5ab242598cfbf4752327718">More...</a><br /></td></tr>
<tr class="separator:a127c071eb5ab242598cfbf4752327718"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07d3006c13efa25dc0abf1d1f55d1092"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_common_1_1_t_vector.html#a07d3006c13efa25dc0abf1d1f55d1092">Pop</a> (bool bAllowAutoShrink=false)</td></tr>
<tr class="memdesc:a07d3006c13efa25dc0abf1d1f55d1092"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes one element from the end of vector.  <a href="class_common_1_1_t_vector.html#a07d3006c13efa25dc0abf1d1f55d1092">More...</a><br /></td></tr>
<tr class="separator:a07d3006c13efa25dc0abf1d1f55d1092"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8930b8690ca6ac278b78f44df731cdc6"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_common_1_1_t_vector.html#a8930b8690ca6ac278b78f44df731cdc6">SafePop</a> (bool bAllowAutoShrink=false)</td></tr>
<tr class="memdesc:a8930b8690ca6ac278b78f44df731cdc6"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_common_1_1_t_vector.html#a07d3006c13efa25dc0abf1d1f55d1092" title="Removes one element from the end of vector.">Pop()</a> with range check.  <a href="class_common_1_1_t_vector.html#a8930b8690ca6ac278b78f44df731cdc6">More...</a><br /></td></tr>
<tr class="separator:a8930b8690ca6ac278b78f44df731cdc6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80d2a825549568315b2f2f8c00bd5a29"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_common_1_1_t_vector.html#a80d2a825549568315b2f2f8c00bd5a29">PopMultiple</a> (size_t ElementsCount, bool bAllowAutoShrink=false)</td></tr>
<tr class="memdesc:a80d2a825549568315b2f2f8c00bd5a29"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes N elements from the end of vector.  <a href="class_common_1_1_t_vector.html#a80d2a825549568315b2f2f8c00bd5a29">More...</a><br /></td></tr>
<tr class="separator:a80d2a825549568315b2f2f8c00bd5a29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6bebae24de311966508f2e60e744987c"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_common_1_1_t_vector.html#a6bebae24de311966508f2e60e744987c">Shift</a> (bool bAllowAutoShrink=false)</td></tr>
<tr class="memdesc:a6bebae24de311966508f2e60e744987c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes one element from the beginning of vector.  <a href="class_common_1_1_t_vector.html#a6bebae24de311966508f2e60e744987c">More...</a><br /></td></tr>
<tr class="separator:a6bebae24de311966508f2e60e744987c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba9bb87bd0d8367d341904b90915425c"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_common_1_1_t_vector.html#aba9bb87bd0d8367d341904b90915425c">SafeShift</a> (bool bAllowAutoShrink=false)</td></tr>
<tr class="memdesc:aba9bb87bd0d8367d341904b90915425c"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_common_1_1_t_vector.html#a6bebae24de311966508f2e60e744987c" title="Removes one element from the beginning of vector.">Shift()</a> with range check.  <a href="class_common_1_1_t_vector.html#aba9bb87bd0d8367d341904b90915425c">More...</a><br /></td></tr>
<tr class="separator:aba9bb87bd0d8367d341904b90915425c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ccce21ef8696b9729eca027b2455a0f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_common_1_1_t_vector.html#a5ccce21ef8696b9729eca027b2455a0f">ShiftMultiple</a> (size_t ElementsCount, bool bAllowAutoShrink=false)</td></tr>
<tr class="memdesc:a5ccce21ef8696b9729eca027b2455a0f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes N elements from the beginning of vector.  <a href="class_common_1_1_t_vector.html#a5ccce21ef8696b9729eca027b2455a0f">More...</a><br /></td></tr>
<tr class="separator:a5ccce21ef8696b9729eca027b2455a0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2726e32a3100881be46a26f33f0a77f0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_common_1_1_t_vector.html#a2726e32a3100881be46a26f33f0a77f0">Erase</a> (size_t Position, bool bAllowAutoShrink=false)</td></tr>
<tr class="memdesc:a2726e32a3100881be46a26f33f0a77f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes element with specified position.  <a href="class_common_1_1_t_vector.html#a2726e32a3100881be46a26f33f0a77f0">More...</a><br /></td></tr>
<tr class="separator:a2726e32a3100881be46a26f33f0a77f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5fec059588a4ce275c5a02ad8a8135d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_common_1_1_t_vector.html#aa5fec059588a4ce275c5a02ad8a8135d">EraseMultiple</a> (size_t PositionFrom, size_t PositionTo, bool bAllowAutoShrink=false)</td></tr>
<tr class="memdesc:aa5fec059588a4ce275c5a02ad8a8135d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes range of elements from vector.  <a href="class_common_1_1_t_vector.html#aa5fec059588a4ce275c5a02ad8a8135d">More...</a><br /></td></tr>
<tr class="separator:aa5fec059588a4ce275c5a02ad8a8135d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4ce7e570833e9f5b6ed8a87529e7acb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_common_1_1_t_vector.html#aa4ce7e570833e9f5b6ed8a87529e7acb">Reserve</a> (size_t NewCapacity)</td></tr>
<tr class="memdesc:aa4ce7e570833e9f5b6ed8a87529e7acb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocates elements internally for the future use.  <a href="class_common_1_1_t_vector.html#aa4ce7e570833e9f5b6ed8a87529e7acb">More...</a><br /></td></tr>
<tr class="separator:aa4ce7e570833e9f5b6ed8a87529e7acb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60f6c69c7451b622aca89e24cf81ec61"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_common_1_1_t_vector.html#a60f6c69c7451b622aca89e24cf81ec61">Resize</a> (size_t NewSize, const T &amp;DefaultValue={}, bool bAllowAutoShrink=false)</td></tr>
<tr class="memdesc:a60f6c69c7451b622aca89e24cf81ec61"><td class="mdescLeft">&#160;</td><td class="mdescRight">Changes size of vector.  <a href="class_common_1_1_t_vector.html#a60f6c69c7451b622aca89e24cf81ec61">More...</a><br /></td></tr>
<tr class="separator:a60f6c69c7451b622aca89e24cf81ec61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8787ec26793a93cb9f1dfe3da108a21"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_common_1_1_t_vector.html#aa8787ec26793a93cb9f1dfe3da108a21">ShrinkToFit</a> ()</td></tr>
<tr class="memdesc:aa8787ec26793a93cb9f1dfe3da108a21"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears memory that was reserved for future use.  <a href="class_common_1_1_t_vector.html#aa8787ec26793a93cb9f1dfe3da108a21">More...</a><br /></td></tr>
<tr class="separator:aa8787ec26793a93cb9f1dfe3da108a21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6d8ea8716f37c92564f7461e7eb43c9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_common_1_1_t_vector.html#ae6d8ea8716f37c92564f7461e7eb43c9">Clear</a> (bool bDoFreeMemory=false)</td></tr>
<tr class="memdesc:ae6d8ea8716f37c92564f7461e7eb43c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes all elements from the vector.  <a href="class_common_1_1_t_vector.html#ae6d8ea8716f37c92564f7461e7eb43c9">More...</a><br /></td></tr>
<tr class="separator:ae6d8ea8716f37c92564f7461e7eb43c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab369d828bdc8322133940541b4f9c9f8"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_common_1_1_t_vector.html#ab369d828bdc8322133940541b4f9c9f8">GetSize</a> () const noexcept</td></tr>
<tr class="memdesc:ab369d828bdc8322133940541b4f9c9f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Size is number of elements that you can use.  <a href="class_common_1_1_t_vector.html#ab369d828bdc8322133940541b4f9c9f8">More...</a><br /></td></tr>
<tr class="separator:ab369d828bdc8322133940541b4f9c9f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d93c3a7bd6c62d556020e93fc0e0fae"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_common_1_1_t_vector.html#a9d93c3a7bd6c62d556020e93fc0e0fae">GetCapacity</a> () const noexcept</td></tr>
<tr class="memdesc:a9d93c3a7bd6c62d556020e93fc0e0fae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Capacity is Size + reserved space for the future use.  <a href="class_common_1_1_t_vector.html#a9d93c3a7bd6c62d556020e93fc0e0fae">More...</a><br /></td></tr>
<tr class="separator:a9d93c3a7bd6c62d556020e93fc0e0fae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae50f2b9986d95285fb1827e60c0a039b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_common_1_1_t_vector.html#ae50f2b9986d95285fb1827e60c0a039b">IsEmpty</a> () const noexcept</td></tr>
<tr class="memdesc:ae50f2b9986d95285fb1827e60c0a039b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simple check if size of this vector equals 0.  <a href="class_common_1_1_t_vector.html#ae50f2b9986d95285fb1827e60c0a039b">More...</a><br /></td></tr>
<tr class="separator:ae50f2b9986d95285fb1827e60c0a039b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49e1cd83803d7579f8e3febbaff17f2b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_common_1_1_t_vector.html#a49e1cd83803d7579f8e3febbaff17f2b">SetCapacityRule</a> (<a class="el" href="class_common_1_1_t_vector.html#a519da74235c0cc6e30868e3aaf24f1d9">EReservedCapacityRule</a> CapacityRule) noexcept</td></tr>
<tr class="memdesc:a49e1cd83803d7579f8e3febbaff17f2b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set enum value that will describe how re-allocation works when elements are added / removed from vertor. Reallocation on removal happens only if bool bAllowAutoShrink was passed with supported operation.  <a href="class_common_1_1_t_vector.html#a49e1cd83803d7579f8e3febbaff17f2b">More...</a><br /></td></tr>
<tr class="separator:a49e1cd83803d7579f8e3febbaff17f2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afde279a09ddc6246c2455f7e1c8df7fd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_common_1_1_t_vector.html#a519da74235c0cc6e30868e3aaf24f1d9">EReservedCapacityRule</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_common_1_1_t_vector.html#afde279a09ddc6246c2455f7e1c8df7fd">GetCapacityRule</a> () const noexcept</td></tr>
<tr class="memdesc:afde279a09ddc6246c2455f7e1c8df7fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns Capacity rule that is currently applied. It affects how elements are allocated &amp; destructed.  <a href="class_common_1_1_t_vector.html#afde279a09ddc6246c2455f7e1c8df7fd">More...</a><br /></td></tr>
<tr class="separator:afde279a09ddc6246c2455f7e1c8df7fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c58ce64e0c1556c4cbb008ce477ce6e"><td class="memItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_common_1_1_t_vector.html#a5c58ce64e0c1556c4cbb008ce477ce6e">Front</a> ()</td></tr>
<tr class="memdesc:a5c58ce64e0c1556c4cbb008ce477ce6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides access to the first element.  <a href="class_common_1_1_t_vector.html#a5c58ce64e0c1556c4cbb008ce477ce6e">More...</a><br /></td></tr>
<tr class="separator:a5c58ce64e0c1556c4cbb008ce477ce6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a17a4d52a156ba905fa6c03e413e245"><td class="memItemLeft" align="right" valign="top">const T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_common_1_1_t_vector.html#a5a17a4d52a156ba905fa6c03e413e245">Front</a> () const</td></tr>
<tr class="memdesc:a5a17a4d52a156ba905fa6c03e413e245"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_common_1_1_t_vector.html#a5c58ce64e0c1556c4cbb008ce477ce6e" title="Provides access to the first element.">Front()</a> for const vectors.  <a href="class_common_1_1_t_vector.html#a5a17a4d52a156ba905fa6c03e413e245">More...</a><br /></td></tr>
<tr class="separator:a5a17a4d52a156ba905fa6c03e413e245"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a038ce8266736da3ea9999be8c7d388ca"><td class="memItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_common_1_1_t_vector.html#a038ce8266736da3ea9999be8c7d388ca">SafeFront</a> ()</td></tr>
<tr class="memdesc:a038ce8266736da3ea9999be8c7d388ca"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_common_1_1_t_vector.html#a5c58ce64e0c1556c4cbb008ce477ce6e" title="Provides access to the first element.">Front()</a> with range check.  <a href="class_common_1_1_t_vector.html#a038ce8266736da3ea9999be8c7d388ca">More...</a><br /></td></tr>
<tr class="separator:a038ce8266736da3ea9999be8c7d388ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9edc2a3851d07627f333c4ff1d5f9aa7"><td class="memItemLeft" align="right" valign="top">const T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_common_1_1_t_vector.html#a9edc2a3851d07627f333c4ff1d5f9aa7">SafeFront</a> () const</td></tr>
<tr class="memdesc:a9edc2a3851d07627f333c4ff1d5f9aa7"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_common_1_1_t_vector.html#a038ce8266736da3ea9999be8c7d388ca" title="Front() with range check.">SafeFront()</a> for const vectors.  <a href="class_common_1_1_t_vector.html#a9edc2a3851d07627f333c4ff1d5f9aa7">More...</a><br /></td></tr>
<tr class="separator:a9edc2a3851d07627f333c4ff1d5f9aa7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79ad5cf5cabca33285e267595700edbb"><td class="memItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_common_1_1_t_vector.html#a79ad5cf5cabca33285e267595700edbb">Back</a> ()</td></tr>
<tr class="memdesc:a79ad5cf5cabca33285e267595700edbb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides access to the last element.  <a href="class_common_1_1_t_vector.html#a79ad5cf5cabca33285e267595700edbb">More...</a><br /></td></tr>
<tr class="separator:a79ad5cf5cabca33285e267595700edbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a093d18082c8ed965ad337cc8638981c8"><td class="memItemLeft" align="right" valign="top">const T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_common_1_1_t_vector.html#a093d18082c8ed965ad337cc8638981c8">Back</a> () const</td></tr>
<tr class="memdesc:a093d18082c8ed965ad337cc8638981c8"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_common_1_1_t_vector.html#a79ad5cf5cabca33285e267595700edbb" title="Provides access to the last element.">Back()</a> for const vectors.  <a href="class_common_1_1_t_vector.html#a093d18082c8ed965ad337cc8638981c8">More...</a><br /></td></tr>
<tr class="separator:a093d18082c8ed965ad337cc8638981c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adcde95defa55d50bbd2aa889fc0632ad"><td class="memItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_common_1_1_t_vector.html#adcde95defa55d50bbd2aa889fc0632ad">SafeBack</a> ()</td></tr>
<tr class="memdesc:adcde95defa55d50bbd2aa889fc0632ad"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_common_1_1_t_vector.html#a79ad5cf5cabca33285e267595700edbb" title="Provides access to the last element.">Back()</a> with range check.  <a href="class_common_1_1_t_vector.html#adcde95defa55d50bbd2aa889fc0632ad">More...</a><br /></td></tr>
<tr class="separator:adcde95defa55d50bbd2aa889fc0632ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf25672d9a2be8530f3d59536a8cc55a"><td class="memItemLeft" align="right" valign="top">const T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_common_1_1_t_vector.html#acf25672d9a2be8530f3d59536a8cc55a">SafeBack</a> () const</td></tr>
<tr class="memdesc:acf25672d9a2be8530f3d59536a8cc55a"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_common_1_1_t_vector.html#adcde95defa55d50bbd2aa889fc0632ad" title="Back() with range check.">SafeBack()</a> for const vectors.  <a href="class_common_1_1_t_vector.html#acf25672d9a2be8530f3d59536a8cc55a">More...</a><br /></td></tr>
<tr class="separator:acf25672d9a2be8530f3d59536a8cc55a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:accd4a771d43b896a745cf2a4f2ff62ea"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_common_1_1_t_vector.html#a652c25a5143b2494732a42f6cf84c968">CIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_common_1_1_t_vector.html#accd4a771d43b896a745cf2a4f2ff62ea">Begin</a> ()</td></tr>
<tr class="memdesc:accd4a771d43b896a745cf2a4f2ff62ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterator pointing to the first elem.  <a href="class_common_1_1_t_vector.html#accd4a771d43b896a745cf2a4f2ff62ea">More...</a><br /></td></tr>
<tr class="separator:accd4a771d43b896a745cf2a4f2ff62ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e1fd9f1ecb757f61e9d6ffb6a63a8fb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_common_1_1_t_vector.html#ae0cbcdf3adbfe67697fdf44d86e6f24d">CConstIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_common_1_1_t_vector.html#a0e1fd9f1ecb757f61e9d6ffb6a63a8fb">ConstBegin</a> () const</td></tr>
<tr class="memdesc:a0e1fd9f1ecb757f61e9d6ffb6a63a8fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterator pointing to the first elem (const).  <a href="class_common_1_1_t_vector.html#a0e1fd9f1ecb757f61e9d6ffb6a63a8fb">More...</a><br /></td></tr>
<tr class="separator:a0e1fd9f1ecb757f61e9d6ffb6a63a8fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb2b0f6f89ddf9207afdc82b9e016fd3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_common_1_1_t_vector.html#abc0c21b3e1404bbbc0ea2f4d44020b5d">CReverseIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_common_1_1_t_vector.html#aeb2b0f6f89ddf9207afdc82b9e016fd3">ReverseBegin</a> ()</td></tr>
<tr class="memdesc:aeb2b0f6f89ddf9207afdc82b9e016fd3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reverse iterator pointing to the first elem.  <a href="class_common_1_1_t_vector.html#aeb2b0f6f89ddf9207afdc82b9e016fd3">More...</a><br /></td></tr>
<tr class="separator:aeb2b0f6f89ddf9207afdc82b9e016fd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adcdafcdc204ab13361c046b4079d58a5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_common_1_1_t_vector.html#a620ba915fe6601254e82360781ac8cd3">CConstReverseIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_common_1_1_t_vector.html#adcdafcdc204ab13361c046b4079d58a5">ConstReverseBegin</a> () const</td></tr>
<tr class="memdesc:adcdafcdc204ab13361c046b4079d58a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reverse iterator pointing to the first elem (const).  <a href="class_common_1_1_t_vector.html#adcdafcdc204ab13361c046b4079d58a5">More...</a><br /></td></tr>
<tr class="separator:adcdafcdc204ab13361c046b4079d58a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac99e39a82ba80e52d5d32000b679ef3d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_common_1_1_t_vector.html#ab3a5ce0edf70da5e5d94bbc280f140cb">CSafeIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_common_1_1_t_vector.html#ac99e39a82ba80e52d5d32000b679ef3d">SafeBegin</a> ()</td></tr>
<tr class="memdesc:ac99e39a82ba80e52d5d32000b679ef3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Safe iterator pointing to the first elem.  <a href="class_common_1_1_t_vector.html#ac99e39a82ba80e52d5d32000b679ef3d">More...</a><br /></td></tr>
<tr class="separator:ac99e39a82ba80e52d5d32000b679ef3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0376e0a629ec7afa97bcbcb274db1e0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_common_1_1_t_vector.html#a87927820350f8bc80ac7ad41cc97753a">CSafeConstIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_common_1_1_t_vector.html#ab0376e0a629ec7afa97bcbcb274db1e0">SafeConstBegin</a> () const</td></tr>
<tr class="memdesc:ab0376e0a629ec7afa97bcbcb274db1e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Safe iterator pointing to the first elem (const).  <a href="class_common_1_1_t_vector.html#ab0376e0a629ec7afa97bcbcb274db1e0">More...</a><br /></td></tr>
<tr class="separator:ab0376e0a629ec7afa97bcbcb274db1e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7cbc34f370a123b70406dce5c9e4f7f0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_common_1_1_t_vector.html#a0344a8c164afdf2d7ba66c07be804f79">CSafeReverseIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_common_1_1_t_vector.html#a7cbc34f370a123b70406dce5c9e4f7f0">SafeReverseBegin</a> ()</td></tr>
<tr class="memdesc:a7cbc34f370a123b70406dce5c9e4f7f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Safe reverse iterator pointing to the first elem.  <a href="class_common_1_1_t_vector.html#a7cbc34f370a123b70406dce5c9e4f7f0">More...</a><br /></td></tr>
<tr class="separator:a7cbc34f370a123b70406dce5c9e4f7f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7867f17103c8ad7c97c1a02d1e91ae93"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_common_1_1_t_vector.html#a903eca6362843ebacffd6b63ae85b5db">CSafeConstReverseIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_common_1_1_t_vector.html#a7867f17103c8ad7c97c1a02d1e91ae93">SafeConstReverseBegin</a> () const</td></tr>
<tr class="memdesc:a7867f17103c8ad7c97c1a02d1e91ae93"><td class="mdescLeft">&#160;</td><td class="mdescRight">Safe reverse iterator pointing to the first elem (const).  <a href="class_common_1_1_t_vector.html#a7867f17103c8ad7c97c1a02d1e91ae93">More...</a><br /></td></tr>
<tr class="separator:a7867f17103c8ad7c97c1a02d1e91ae93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6f082451d8a03611bfb5c627155ed31"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_common_1_1_t_vector.html#a652c25a5143b2494732a42f6cf84c968">CIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_common_1_1_t_vector.html#ae6f082451d8a03611bfb5c627155ed31">End</a> ()</td></tr>
<tr class="memdesc:ae6f082451d8a03611bfb5c627155ed31"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterator pointing to the elem after last.  <a href="class_common_1_1_t_vector.html#ae6f082451d8a03611bfb5c627155ed31">More...</a><br /></td></tr>
<tr class="separator:ae6f082451d8a03611bfb5c627155ed31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2424af5eaa1d4c38c5df07466c37b2bb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_common_1_1_t_vector.html#ae0cbcdf3adbfe67697fdf44d86e6f24d">CConstIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_common_1_1_t_vector.html#a2424af5eaa1d4c38c5df07466c37b2bb">ConstEnd</a> () const</td></tr>
<tr class="memdesc:a2424af5eaa1d4c38c5df07466c37b2bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterator pointing to the elem after last (const).  <a href="class_common_1_1_t_vector.html#a2424af5eaa1d4c38c5df07466c37b2bb">More...</a><br /></td></tr>
<tr class="separator:a2424af5eaa1d4c38c5df07466c37b2bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a235eac07ed0051f720efdaac7b7a6f9f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_common_1_1_t_vector.html#abc0c21b3e1404bbbc0ea2f4d44020b5d">CReverseIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_common_1_1_t_vector.html#a235eac07ed0051f720efdaac7b7a6f9f">ReverseEnd</a> ()</td></tr>
<tr class="memdesc:a235eac07ed0051f720efdaac7b7a6f9f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reverse iterator pointing to the elem after last.  <a href="class_common_1_1_t_vector.html#a235eac07ed0051f720efdaac7b7a6f9f">More...</a><br /></td></tr>
<tr class="separator:a235eac07ed0051f720efdaac7b7a6f9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af50fcd9bee3c5ecb912d4bac5f77462d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_common_1_1_t_vector.html#a620ba915fe6601254e82360781ac8cd3">CConstReverseIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_common_1_1_t_vector.html#af50fcd9bee3c5ecb912d4bac5f77462d">ConstReverseEnd</a> () const</td></tr>
<tr class="memdesc:af50fcd9bee3c5ecb912d4bac5f77462d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reverse iterator pointing to the elem after last (const).  <a href="class_common_1_1_t_vector.html#af50fcd9bee3c5ecb912d4bac5f77462d">More...</a><br /></td></tr>
<tr class="separator:af50fcd9bee3c5ecb912d4bac5f77462d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb4f534420bd80b50faeba5dfc7b4195"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_common_1_1_t_vector.html#ab3a5ce0edf70da5e5d94bbc280f140cb">CSafeIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_common_1_1_t_vector.html#acb4f534420bd80b50faeba5dfc7b4195">SafeEnd</a> ()</td></tr>
<tr class="memdesc:acb4f534420bd80b50faeba5dfc7b4195"><td class="mdescLeft">&#160;</td><td class="mdescRight">Safe iterator pointing to the elem after last.  <a href="class_common_1_1_t_vector.html#acb4f534420bd80b50faeba5dfc7b4195">More...</a><br /></td></tr>
<tr class="separator:acb4f534420bd80b50faeba5dfc7b4195"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6eca58c21a6dcf351198541e9d062785"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_common_1_1_t_vector.html#a87927820350f8bc80ac7ad41cc97753a">CSafeConstIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_common_1_1_t_vector.html#a6eca58c21a6dcf351198541e9d062785">SafeConstEnd</a> () const</td></tr>
<tr class="memdesc:a6eca58c21a6dcf351198541e9d062785"><td class="mdescLeft">&#160;</td><td class="mdescRight">Safe iterator pointing to the elem after last (const).  <a href="class_common_1_1_t_vector.html#a6eca58c21a6dcf351198541e9d062785">More...</a><br /></td></tr>
<tr class="separator:a6eca58c21a6dcf351198541e9d062785"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e75dd85282a98d1001961adece43616"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_common_1_1_t_vector.html#a0344a8c164afdf2d7ba66c07be804f79">CSafeReverseIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_common_1_1_t_vector.html#a1e75dd85282a98d1001961adece43616">SafeReverseEnd</a> ()</td></tr>
<tr class="memdesc:a1e75dd85282a98d1001961adece43616"><td class="mdescLeft">&#160;</td><td class="mdescRight">Safe reverse iterator pointing to the elem after last.  <a href="class_common_1_1_t_vector.html#a1e75dd85282a98d1001961adece43616">More...</a><br /></td></tr>
<tr class="separator:a1e75dd85282a98d1001961adece43616"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb49407670de6b064203103198c25fb1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_common_1_1_t_vector.html#a903eca6362843ebacffd6b63ae85b5db">CSafeConstReverseIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_common_1_1_t_vector.html#adb49407670de6b064203103198c25fb1">SafeConstReverseEnd</a> () const</td></tr>
<tr class="memdesc:adb49407670de6b064203103198c25fb1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Safe reverse it. pointing to elem after last (const).  <a href="class_common_1_1_t_vector.html#adb49407670de6b064203103198c25fb1">More...</a><br /></td></tr>
<tr class="separator:adb49407670de6b064203103198c25fb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a311c8d0d5bde17cb4aaa9fdd1f5c541f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_common_1_1_t_vector.html#a652c25a5143b2494732a42f6cf84c968">CIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_common_1_1_t_vector.html#a311c8d0d5bde17cb4aaa9fdd1f5c541f">begin</a> ()</td></tr>
<tr class="memdesc:a311c8d0d5bde17cb4aaa9fdd1f5c541f"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_common_1_1_t_vector.html#accd4a771d43b896a745cf2a4f2ff62ea" title="Iterator pointing to the first elem.">Begin()</a> alias (for compatibity)  <a href="class_common_1_1_t_vector.html#a311c8d0d5bde17cb4aaa9fdd1f5c541f">More...</a><br /></td></tr>
<tr class="separator:a311c8d0d5bde17cb4aaa9fdd1f5c541f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaab3b25c6522737e84823dd07841b08b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_common_1_1_t_vector.html#ae0cbcdf3adbfe67697fdf44d86e6f24d">CConstIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_common_1_1_t_vector.html#aaab3b25c6522737e84823dd07841b08b">begin</a> () const</td></tr>
<tr class="memdesc:aaab3b25c6522737e84823dd07841b08b"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_common_1_1_t_vector.html#a0e1fd9f1ecb757f61e9d6ffb6a63a8fb" title="Iterator pointing to the first elem (const).">ConstBegin()</a> alias (overloaded, for compatibity)  <a href="class_common_1_1_t_vector.html#aaab3b25c6522737e84823dd07841b08b">More...</a><br /></td></tr>
<tr class="separator:aaab3b25c6522737e84823dd07841b08b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b9a93a0a3f873b4171382afa10bf804"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_common_1_1_t_vector.html#ae0cbcdf3adbfe67697fdf44d86e6f24d">CConstIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_common_1_1_t_vector.html#a9b9a93a0a3f873b4171382afa10bf804">cbegin</a> () const</td></tr>
<tr class="memdesc:a9b9a93a0a3f873b4171382afa10bf804"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_common_1_1_t_vector.html#a0e1fd9f1ecb757f61e9d6ffb6a63a8fb" title="Iterator pointing to the first elem (const).">ConstBegin()</a> alias (for compatibity)  <a href="class_common_1_1_t_vector.html#a9b9a93a0a3f873b4171382afa10bf804">More...</a><br /></td></tr>
<tr class="separator:a9b9a93a0a3f873b4171382afa10bf804"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a099e402047ded53305319675e93f442c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_common_1_1_t_vector.html#abc0c21b3e1404bbbc0ea2f4d44020b5d">CReverseIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_common_1_1_t_vector.html#a099e402047ded53305319675e93f442c">rbegin</a> ()</td></tr>
<tr class="memdesc:a099e402047ded53305319675e93f442c"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_common_1_1_t_vector.html#aeb2b0f6f89ddf9207afdc82b9e016fd3" title="Reverse iterator pointing to the first elem.">ReverseBegin()</a> alias (for compatibity)  <a href="class_common_1_1_t_vector.html#a099e402047ded53305319675e93f442c">More...</a><br /></td></tr>
<tr class="separator:a099e402047ded53305319675e93f442c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78b186c7438610a815abf110f3eb0bde"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_common_1_1_t_vector.html#a620ba915fe6601254e82360781ac8cd3">CConstReverseIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_common_1_1_t_vector.html#a78b186c7438610a815abf110f3eb0bde">rbegin</a> () const</td></tr>
<tr class="memdesc:a78b186c7438610a815abf110f3eb0bde"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_common_1_1_t_vector.html#adcdafcdc204ab13361c046b4079d58a5" title="Reverse iterator pointing to the first elem (const).">ConstReverseBegin()</a> alias (overloaded, for compatibity)  <a href="class_common_1_1_t_vector.html#a78b186c7438610a815abf110f3eb0bde">More...</a><br /></td></tr>
<tr class="separator:a78b186c7438610a815abf110f3eb0bde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:addfd624b66342be573447b93a3e139f7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_common_1_1_t_vector.html#a620ba915fe6601254e82360781ac8cd3">CConstReverseIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_common_1_1_t_vector.html#addfd624b66342be573447b93a3e139f7">crbegin</a> () const</td></tr>
<tr class="memdesc:addfd624b66342be573447b93a3e139f7"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_common_1_1_t_vector.html#adcdafcdc204ab13361c046b4079d58a5" title="Reverse iterator pointing to the first elem (const).">ConstReverseBegin()</a> alias (for compatibity)  <a href="class_common_1_1_t_vector.html#addfd624b66342be573447b93a3e139f7">More...</a><br /></td></tr>
<tr class="separator:addfd624b66342be573447b93a3e139f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a008d5b2b5d7bbc4e4a5ccea077bc71"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_common_1_1_t_vector.html#a652c25a5143b2494732a42f6cf84c968">CIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_common_1_1_t_vector.html#a1a008d5b2b5d7bbc4e4a5ccea077bc71">end</a> ()</td></tr>
<tr class="memdesc:a1a008d5b2b5d7bbc4e4a5ccea077bc71"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_common_1_1_t_vector.html#ae6f082451d8a03611bfb5c627155ed31" title="Iterator pointing to the elem after last.">End()</a> alias (for compatibity)  <a href="class_common_1_1_t_vector.html#a1a008d5b2b5d7bbc4e4a5ccea077bc71">More...</a><br /></td></tr>
<tr class="separator:a1a008d5b2b5d7bbc4e4a5ccea077bc71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd5e2129f351d6102bf4987ec1e2971e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_common_1_1_t_vector.html#ae0cbcdf3adbfe67697fdf44d86e6f24d">CConstIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_common_1_1_t_vector.html#abd5e2129f351d6102bf4987ec1e2971e">end</a> () const</td></tr>
<tr class="memdesc:abd5e2129f351d6102bf4987ec1e2971e"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_common_1_1_t_vector.html#a2424af5eaa1d4c38c5df07466c37b2bb" title="Iterator pointing to the elem after last (const).">ConstEnd()</a> alias (overloaded, for compatibity)  <a href="class_common_1_1_t_vector.html#abd5e2129f351d6102bf4987ec1e2971e">More...</a><br /></td></tr>
<tr class="separator:abd5e2129f351d6102bf4987ec1e2971e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c52709393f927cda247027dc60e0b9e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_common_1_1_t_vector.html#ae0cbcdf3adbfe67697fdf44d86e6f24d">CConstIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_common_1_1_t_vector.html#a8c52709393f927cda247027dc60e0b9e">cend</a> () const</td></tr>
<tr class="memdesc:a8c52709393f927cda247027dc60e0b9e"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_common_1_1_t_vector.html#a2424af5eaa1d4c38c5df07466c37b2bb" title="Iterator pointing to the elem after last (const).">ConstEnd()</a> alias (for compatibity)  <a href="class_common_1_1_t_vector.html#a8c52709393f927cda247027dc60e0b9e">More...</a><br /></td></tr>
<tr class="separator:a8c52709393f927cda247027dc60e0b9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93ce41ca7234c18d7fcaf583cd2e0a36"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_common_1_1_t_vector.html#abc0c21b3e1404bbbc0ea2f4d44020b5d">CReverseIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_common_1_1_t_vector.html#a93ce41ca7234c18d7fcaf583cd2e0a36">rend</a> ()</td></tr>
<tr class="memdesc:a93ce41ca7234c18d7fcaf583cd2e0a36"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_common_1_1_t_vector.html#a235eac07ed0051f720efdaac7b7a6f9f" title="Reverse iterator pointing to the elem after last.">ReverseEnd()</a> alias (for compatibity)  <a href="class_common_1_1_t_vector.html#a93ce41ca7234c18d7fcaf583cd2e0a36">More...</a><br /></td></tr>
<tr class="separator:a93ce41ca7234c18d7fcaf583cd2e0a36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac831612b2da9aefedeac345112b603ac"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_common_1_1_t_vector.html#a620ba915fe6601254e82360781ac8cd3">CConstReverseIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_common_1_1_t_vector.html#ac831612b2da9aefedeac345112b603ac">rend</a> () const</td></tr>
<tr class="memdesc:ac831612b2da9aefedeac345112b603ac"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_common_1_1_t_vector.html#af50fcd9bee3c5ecb912d4bac5f77462d" title="Reverse iterator pointing to the elem after last (const).">ConstReverseEnd()</a> alias (overloaded, for compatibity)  <a href="class_common_1_1_t_vector.html#ac831612b2da9aefedeac345112b603ac">More...</a><br /></td></tr>
<tr class="separator:ac831612b2da9aefedeac345112b603ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0de015e10f1db89a438084121c75e33f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_common_1_1_t_vector.html#a620ba915fe6601254e82360781ac8cd3">CConstReverseIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_common_1_1_t_vector.html#a0de015e10f1db89a438084121c75e33f">crend</a> () const</td></tr>
<tr class="memdesc:a0de015e10f1db89a438084121c75e33f"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_common_1_1_t_vector.html#af50fcd9bee3c5ecb912d4bac5f77462d" title="Reverse iterator pointing to the elem after last (const).">ConstReverseEnd()</a> alias (for compatibity)  <a href="class_common_1_1_t_vector.html#a0de015e10f1db89a438084121c75e33f">More...</a><br /></td></tr>
<tr class="separator:a0de015e10f1db89a438084121c75e33f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a1237537b0f430dc5b82043a527185dc3"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_common_1_1_t_vector.html#a1237537b0f430dc5b82043a527185dc3">Swap</a> (<a class="el" href="class_common_1_1_t_vector.html">TVector</a>&lt; T &gt; &amp;Vector1, <a class="el" href="class_common_1_1_t_vector.html">TVector</a>&lt; T &gt; &amp;Vector2) noexcept</td></tr>
<tr class="memdesc:a1237537b0f430dc5b82043a527185dc3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swaps two vectors internally without deep copy.  <a href="class_common_1_1_t_vector.html#a1237537b0f430dc5b82043a527185dc3">More...</a><br /></td></tr>
<tr class="separator:a1237537b0f430dc5b82043a527185dc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename T&gt;<br />
class Common::TVector&lt; T &gt;</h3>

<p>Container representing array that can change its size. </p>
<p>Fast in accessing elements as offsets are used, but not very effective in terms of adding and removing elements. To minimize those drawbacks, there are memory reserving rules that you can manage.</p>
<dl class="section note"><dt>Note</dt><dd>If the logical result of operation may not be determined, there are two methods: one that throws an exception ("Safe" prefix) and another one that does assertion in debug mode. Custom exception is <a class="el" href="class_common_1_1_c_out_of_range.html" title="Represents &quot;Out of Range&quot; error. Can hold message, requested and expected indices.">COutOfRange</a>, derived from <a class="el" href="class_common_1_1_c_exception.html" title="Basic exception class. C-style message is required.">CException</a></dd>
<dd>
May throw std::bad_alloc if allocation fails. Allocation failure in assignment operations will cause the vector to be cleared (as you intended to remove old elements anyway). If allocation fails in insertions, resize, push/pop, etc. - vector will stay in the previous state. </dd></dl>
<dl class="section attention"><dt>Attention</dt><dd>Containing type must provide a default (or empty) constructor. This will be fixed in the future. </dd></dl>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="ae0cbcdf3adbfe67697fdf44d86e6f24d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0cbcdf3adbfe67697fdf44d86e6f24d">&#9670;&nbsp;</a></span>CConstIterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef TIterator&lt;const T*, const T&amp;&gt; <a class="el" href="class_common_1_1_t_vector.html">Common::TVector</a>&lt; T &gt;::<a class="el" href="class_common_1_1_t_vector.html#ae0cbcdf3adbfe67697fdf44d86e6f24d">CConstIterator</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Version of CIterator for const values. </p>

</div>
</div>
<a id="a620ba915fe6601254e82360781ac8cd3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a620ba915fe6601254e82360781ac8cd3">&#9670;&nbsp;</a></span>CConstReverseIterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef TReverseIterator&lt;const T*, const T&amp;&gt; <a class="el" href="class_common_1_1_t_vector.html">Common::TVector</a>&lt; T &gt;::<a class="el" href="class_common_1_1_t_vector.html#a620ba915fe6601254e82360781ac8cd3">CConstReverseIterator</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Version of TReverseIterator for const values. </p>

</div>
</div>
<a id="a652c25a5143b2494732a42f6cf84c968"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a652c25a5143b2494732a42f6cf84c968">&#9670;&nbsp;</a></span>CIterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef TIterator&lt;T*, T&amp;&gt; <a class="el" href="class_common_1_1_t_vector.html">Common::TVector</a>&lt; T &gt;::<a class="el" href="class_common_1_1_t_vector.html#a652c25a5143b2494732a42f6cf84c968">CIterator</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Iterator. Implemented op-s: ++, +=, +, &ndash;, -=, -, ==, !=, =. </p>

</div>
</div>
<a id="abc0c21b3e1404bbbc0ea2f4d44020b5d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc0c21b3e1404bbbc0ea2f4d44020b5d">&#9670;&nbsp;</a></span>CReverseIterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef TReverseIterator&lt;T*, T&amp;&gt; <a class="el" href="class_common_1_1_t_vector.html">Common::TVector</a>&lt; T &gt;::<a class="el" href="class_common_1_1_t_vector.html#abc0c21b3e1404bbbc0ea2f4d44020b5d">CReverseIterator</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reverse iterator. Increment is actually decrement, etc. </p>

</div>
</div>
<a id="a87927820350f8bc80ac7ad41cc97753a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87927820350f8bc80ac7ad41cc97753a">&#9670;&nbsp;</a></span>CSafeConstIterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef TSafeIterator&lt;const T*, const T&amp;&gt; <a class="el" href="class_common_1_1_t_vector.html">Common::TVector</a>&lt; T &gt;::<a class="el" href="class_common_1_1_t_vector.html#a87927820350f8bc80ac7ad41cc97753a">CSafeConstIterator</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Version of TSafeIterator for const values. </p>

</div>
</div>
<a id="a903eca6362843ebacffd6b63ae85b5db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a903eca6362843ebacffd6b63ae85b5db">&#9670;&nbsp;</a></span>CSafeConstReverseIterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef TSafeReverseIterator&lt;const T*, const T&amp;&gt; <a class="el" href="class_common_1_1_t_vector.html">Common::TVector</a>&lt; T &gt;::<a class="el" href="class_common_1_1_t_vector.html#a903eca6362843ebacffd6b63ae85b5db">CSafeConstReverseIterator</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Version of TSafeReverseIterator for const values. </p>

</div>
</div>
<a id="ab3a5ce0edf70da5e5d94bbc280f140cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3a5ce0edf70da5e5d94bbc280f140cb">&#9670;&nbsp;</a></span>CSafeIterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef TSafeIterator&lt;T*, T&amp;&gt; <a class="el" href="class_common_1_1_t_vector.html">Common::TVector</a>&lt; T &gt;::<a class="el" href="class_common_1_1_t_vector.html#ab3a5ce0edf70da5e5d94bbc280f140cb">CSafeIterator</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Iterator that does bounds checking and throws OutOfRange(). </p>

</div>
</div>
<a id="a0344a8c164afdf2d7ba66c07be804f79"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0344a8c164afdf2d7ba66c07be804f79">&#9670;&nbsp;</a></span>CSafeReverseIterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef TSafeReverseIterator&lt;T*, T&amp;&gt; <a class="el" href="class_common_1_1_t_vector.html">Common::TVector</a>&lt; T &gt;::<a class="el" href="class_common_1_1_t_vector.html#a0344a8c164afdf2d7ba66c07be804f79">CSafeReverseIterator</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reverse iterator that can throw OutOfRange(). </p>

</div>
</div>
<h2 class="groupheader">Member Enumeration Documentation</h2>
<a id="a519da74235c0cc6e30868e3aaf24f1d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a519da74235c0cc6e30868e3aaf24f1d9">&#9670;&nbsp;</a></span>EReservedCapacityRule</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="class_common_1_1_t_vector.html#a519da74235c0cc6e30868e3aaf24f1d9">Common::TVector::EReservedCapacityRule</a> : uint8_t</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Used to define how methods deal with Capacity. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a519da74235c0cc6e30868e3aaf24f1d9ac1e19c09f700938f0ff7f1fd4722a3ac"></a>Exponential&#160;</td><td class="fielddoc"><p>[ADD] allocates (NewSize-1)*2 if capacity exceed and vector is not small enough <br  />
 [DEL] allocates 2*Size if Capacity &gt; 4 * Size and vector is not small enough </p>
</td></tr>
<tr><td class="fieldname"><a id="a519da74235c0cc6e30868e3aaf24f1d9a32a843da6ea40ab3b17a3421ccdf671b"></a>Linear&#160;</td><td class="fielddoc"><p>[ADD] allocates NewSize + 3 + 32 / sizeof(T) if capacity exceed <br  />
 [DEL] allocates Size + 4 + 32 / sizeof(T) if size exceeds capacity by more than 2*(8 + 64 / sizeof(T)) </p>
</td></tr>
<tr><td class="fieldname"><a id="a519da74235c0cc6e30868e3aaf24f1d9a661a50974112b2afaa5fc055d89a27de"></a>NeverReserve&#160;</td><td class="fielddoc"><p>[ADD, DEL] memory is never reserved automatically; if true bAllowAutoShrink was passed into another method, then <a class="el" href="class_common_1_1_t_vector.html#aa8787ec26793a93cb9f1dfe3da108a21" title="Clears memory that was reserved for future use.">ShrinkToFit()</a> will be called </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a06f65afe586f1ad373215a4a6023f3d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06f65afe586f1ad373215a4a6023f3d9">&#9670;&nbsp;</a></span>TVector() <span class="overload">[1/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_common_1_1_t_vector.html">Common::TVector</a>&lt; T &gt;::<a class="el" href="class_common_1_1_t_vector.html">TVector</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Empty vector with no heap allocation. </p>

</div>
</div>
<a id="a292d1b33a2c92e092e88704a12180ace"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a292d1b33a2c92e092e88704a12180ace">&#9670;&nbsp;</a></span>TVector() <span class="overload">[2/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_common_1_1_t_vector.html">Common::TVector</a>&lt; T &gt;::<a class="el" href="class_common_1_1_t_vector.html">TVector</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_common_1_1_t_vector.html#a519da74235c0cc6e30868e3aaf24f1d9">EReservedCapacityRule</a>&#160;</td>
          <td class="paramname"><em>CapacityRule</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates empty vector with Capacity preset predefined. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">CapacityRule</td><td>Describes how memory will be reserved </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_common_1_1_t_vector.html#a519da74235c0cc6e30868e3aaf24f1d9" title="Used to define how methods deal with Capacity.">EReservedCapacityRule</a> for more info about presets. </dd></dl>

</div>
</div>
<a id="a32fe4c53e91761c2e74d1c60a129e19e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32fe4c53e91761c2e74d1c60a129e19e">&#9670;&nbsp;</a></span>TVector() <span class="overload">[3/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_common_1_1_t_vector.html">Common::TVector</a>&lt; T &gt;::<a class="el" href="class_common_1_1_t_vector.html">TVector</a> </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>Size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>DefaultValue</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector with pre-allocated elements. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Size</td><td>Number of elements to allocate </td></tr>
    <tr><td class="paramname">DefaultValue</td><td>Optional. Value to initialize with </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>Use <a class="el" href="class_common_1_1_t_vector.html#aa4ce7e570833e9f5b6ed8a87529e7acb" title="Allocates elements internally for the future use.">Reserve()</a> on empty vector to avoid initialization. </dd></dl>

</div>
</div>
<a id="a0a52533465aeda64aca70875ad397acd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a52533465aeda64aca70875ad397acd">&#9670;&nbsp;</a></span>TVector() <span class="overload">[4/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_common_1_1_t_vector.html">Common::TVector</a>&lt; T &gt;::<a class="el" href="class_common_1_1_t_vector.html">TVector</a> </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>Size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T *const&#160;</td>
          <td class="paramname"><em>Array</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Vector constructed from raw dynamic array (copy). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Size</td><td>Number of elements in original array </td></tr>
    <tr><td class="paramname">Array</td><td>Pointer to heap with C-style array </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Array[0] to Array[Size-1] must exist and have the same type as vector. </dd>
<dd>
Raw array is not changed. </dd></dl>

</div>
</div>
<a id="a06352a0489692cda3c97da5e448962c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06352a0489692cda3c97da5e448962c5">&#9670;&nbsp;</a></span>TVector() <span class="overload">[5/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_common_1_1_t_vector.html">Common::TVector</a>&lt; T &gt;::<a class="el" href="class_common_1_1_t_vector.html">TVector</a> </td>
          <td>(</td>
          <td class="paramtype">const std::initializer_list&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>ValuesList</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Modern C++ initialization syntax: name = {...}. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ValuesList</td><td>Initializer list </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8f0b03d7b5296c85fc170e9e1d91f9aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f0b03d7b5296c85fc170e9e1d91f9aa">&#9670;&nbsp;</a></span>TVector() <span class="overload">[6/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<div class="memtemplate">
template&lt;typename IteratorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_common_1_1_t_vector.html">Common::TVector</a>&lt; T &gt;::<a class="el" href="class_common_1_1_t_vector.html">TVector</a> </td>
          <td>(</td>
          <td class="paramtype">IteratorType&#160;</td>
          <td class="paramname"><em>Begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IteratorType&#160;</td>
          <td class="paramname"><em>End</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename std::enable_if&lt;!std::is_integral&lt; IteratorType &gt;::value &gt;::type *&#160;</td>
          <td class="paramname"> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructor to get values from another container. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">IteratorType</td><td>Iterator that implements ++, != and * </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Begin</td><td>Iterator referring to the beginning of container </td></tr>
    <tr><td class="paramname">End</td><td>Iterator referring to the end of container </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afc1503385b6e91ef3c0b11d9f29ca417"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc1503385b6e91ef3c0b11d9f29ca417">&#9670;&nbsp;</a></span>TVector() <span class="overload">[7/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_common_1_1_t_vector.html">Common::TVector</a>&lt; T &gt;::<a class="el" href="class_common_1_1_t_vector.html">TVector</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_common_1_1_t_vector.html">TVector</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>Other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize by copying another <a class="el" href="class_common_1_1_t_vector.html" title="Container representing array that can change its size.">TVector</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Other</td><td>vector to copy </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae80c6e32c6bd2baadc07f46fc7a4fa44"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae80c6e32c6bd2baadc07f46fc7a4fa44">&#9670;&nbsp;</a></span>TVector() <span class="overload">[8/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_common_1_1_t_vector.html">Common::TVector</a>&lt; T &gt;::<a class="el" href="class_common_1_1_t_vector.html">TVector</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_common_1_1_t_vector.html">TVector</a>&lt; T &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>Other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move constructor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Other</td><td>Temporary object to get data from </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a41dbc556f69d28bc8c370afa5a4d6f35"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41dbc556f69d28bc8c370afa5a4d6f35">&#9670;&nbsp;</a></span>~TVector()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_common_1_1_t_vector.html">Common::TVector</a>&lt; T &gt;::~<a class="el" href="class_common_1_1_t_vector.html">TVector</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a35241b84a165059df5fb32fc6a4f4aa1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a35241b84a165059df5fb32fc6a4f4aa1">&#9670;&nbsp;</a></span>Assign()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<div class="memtemplate">
template&lt;typename IteratorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_common_1_1_t_vector.html">Common::TVector</a>&lt; T &gt;::Assign </td>
          <td>(</td>
          <td class="paramtype">IteratorType&#160;</td>
          <td class="paramname"><em>Begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IteratorType&#160;</td>
          <td class="paramname"><em>End</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bAllowAutoShrink</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allows to copy values from another container. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">IteratorType</td><td>Iterator that implements ++, != and * </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Begin</td><td>Iterator referring to the beginning of container </td></tr>
    <tr><td class="paramname">End</td><td>Iterator referring to the end of container </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8e772bfe52d4776ad89cd2e10a032534"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e772bfe52d4776ad89cd2e10a032534">&#9670;&nbsp;</a></span>AutoAt()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T&amp; <a class="el" href="class_common_1_1_t_vector.html">Common::TVector</a>&lt; T &gt;::AutoAt </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>Index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>DefaultValue</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>If element does not exist, this will resize vector and fill newly created elements with provided value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Index</td><td>aka offset value </td></tr>
    <tr><td class="paramname">DefaultValue</td><td>Value to initialize added elements </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to the requested element </dd></dl>
<dl class="section see"><dt>See also</dt><dd>Use operator [] if you are sure, that element exists </dd></dl>

</div>
</div>
<a id="a79ad5cf5cabca33285e267595700edbb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79ad5cf5cabca33285e267595700edbb">&#9670;&nbsp;</a></span>Back() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T&amp; <a class="el" href="class_common_1_1_t_vector.html">Common::TVector</a>&lt; T &gt;::Back </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Provides access to the last element. </p>
<dl class="section return"><dt>Returns</dt><dd>Reference to the last element </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Vector must not be empty. </dd></dl>

</div>
</div>
<a id="a093d18082c8ed965ad337cc8638981c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a093d18082c8ed965ad337cc8638981c8">&#9670;&nbsp;</a></span>Back() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const T&amp; <a class="el" href="class_common_1_1_t_vector.html">Common::TVector</a>&lt; T &gt;::Back </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="class_common_1_1_t_vector.html#a79ad5cf5cabca33285e267595700edbb" title="Provides access to the last element.">Back()</a> for const vectors. </p>

</div>
</div>
<a id="accd4a771d43b896a745cf2a4f2ff62ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#accd4a771d43b896a745cf2a4f2ff62ea">&#9670;&nbsp;</a></span>Begin()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_common_1_1_t_vector.html#a652c25a5143b2494732a42f6cf84c968">CIterator</a> <a class="el" href="class_common_1_1_t_vector.html">Common::TVector</a>&lt; T &gt;::Begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Iterator pointing to the first elem. </p>
<dl class="section return"><dt>Returns</dt><dd>CIterator iterator </dd></dl>

</div>
</div>
<a id="a311c8d0d5bde17cb4aaa9fdd1f5c541f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a311c8d0d5bde17cb4aaa9fdd1f5c541f">&#9670;&nbsp;</a></span>begin() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_common_1_1_t_vector.html#a652c25a5143b2494732a42f6cf84c968">CIterator</a> <a class="el" href="class_common_1_1_t_vector.html">Common::TVector</a>&lt; T &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="class_common_1_1_t_vector.html#accd4a771d43b896a745cf2a4f2ff62ea" title="Iterator pointing to the first elem.">Begin()</a> alias (for compatibity) </p>

</div>
</div>
<a id="aaab3b25c6522737e84823dd07841b08b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaab3b25c6522737e84823dd07841b08b">&#9670;&nbsp;</a></span>begin() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_common_1_1_t_vector.html#ae0cbcdf3adbfe67697fdf44d86e6f24d">CConstIterator</a> <a class="el" href="class_common_1_1_t_vector.html">Common::TVector</a>&lt; T &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="class_common_1_1_t_vector.html#a0e1fd9f1ecb757f61e9d6ffb6a63a8fb" title="Iterator pointing to the first elem (const).">ConstBegin()</a> alias (overloaded, for compatibity) </p>

</div>
</div>
<a id="a9b9a93a0a3f873b4171382afa10bf804"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b9a93a0a3f873b4171382afa10bf804">&#9670;&nbsp;</a></span>cbegin()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_common_1_1_t_vector.html#ae0cbcdf3adbfe67697fdf44d86e6f24d">CConstIterator</a> <a class="el" href="class_common_1_1_t_vector.html">Common::TVector</a>&lt; T &gt;::cbegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="class_common_1_1_t_vector.html#a0e1fd9f1ecb757f61e9d6ffb6a63a8fb" title="Iterator pointing to the first elem (const).">ConstBegin()</a> alias (for compatibity) </p>

</div>
</div>
<a id="a8c52709393f927cda247027dc60e0b9e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c52709393f927cda247027dc60e0b9e">&#9670;&nbsp;</a></span>cend()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_common_1_1_t_vector.html#ae0cbcdf3adbfe67697fdf44d86e6f24d">CConstIterator</a> <a class="el" href="class_common_1_1_t_vector.html">Common::TVector</a>&lt; T &gt;::cend </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="class_common_1_1_t_vector.html#a2424af5eaa1d4c38c5df07466c37b2bb" title="Iterator pointing to the elem after last (const).">ConstEnd()</a> alias (for compatibity) </p>

</div>
</div>
<a id="ae6d8ea8716f37c92564f7461e7eb43c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6d8ea8716f37c92564f7461e7eb43c9">&#9670;&nbsp;</a></span>Clear()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_common_1_1_t_vector.html">Common::TVector</a>&lt; T &gt;::Clear </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bDoFreeMemory</em> = <code>false</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes all elements from the vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bDoForceDelete</td><td>If set to true, will also update capacity. otherwise, actual delete operation will not be called </td></tr>
  </table>
  </dd>
</dl>
<dl class="section attention"><dt>Attention</dt><dd>Set bool to true if you really want to free memory. </dd></dl>

</div>
</div>
<a id="a0e1fd9f1ecb757f61e9d6ffb6a63a8fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e1fd9f1ecb757f61e9d6ffb6a63a8fb">&#9670;&nbsp;</a></span>ConstBegin()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_common_1_1_t_vector.html#ae0cbcdf3adbfe67697fdf44d86e6f24d">CConstIterator</a> <a class="el" href="class_common_1_1_t_vector.html">Common::TVector</a>&lt; T &gt;::ConstBegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Iterator pointing to the first elem (const). </p>
<dl class="section return"><dt>Returns</dt><dd>CConstIterator iterator </dd></dl>

</div>
</div>
<a id="a2424af5eaa1d4c38c5df07466c37b2bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2424af5eaa1d4c38c5df07466c37b2bb">&#9670;&nbsp;</a></span>ConstEnd()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_common_1_1_t_vector.html#ae0cbcdf3adbfe67697fdf44d86e6f24d">CConstIterator</a> <a class="el" href="class_common_1_1_t_vector.html">Common::TVector</a>&lt; T &gt;::ConstEnd </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Iterator pointing to the elem after last (const). </p>
<dl class="section return"><dt>Returns</dt><dd>CConstIterator iterator </dd></dl>

</div>
</div>
<a id="adcdafcdc204ab13361c046b4079d58a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adcdafcdc204ab13361c046b4079d58a5">&#9670;&nbsp;</a></span>ConstReverseBegin()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_common_1_1_t_vector.html#a620ba915fe6601254e82360781ac8cd3">CConstReverseIterator</a> <a class="el" href="class_common_1_1_t_vector.html">Common::TVector</a>&lt; T &gt;::ConstReverseBegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reverse iterator pointing to the first elem (const). </p>
<dl class="section return"><dt>Returns</dt><dd>CConstReverseIterator iterator </dd></dl>

</div>
</div>
<a id="af50fcd9bee3c5ecb912d4bac5f77462d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af50fcd9bee3c5ecb912d4bac5f77462d">&#9670;&nbsp;</a></span>ConstReverseEnd()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_common_1_1_t_vector.html#a620ba915fe6601254e82360781ac8cd3">CConstReverseIterator</a> <a class="el" href="class_common_1_1_t_vector.html">Common::TVector</a>&lt; T &gt;::ConstReverseEnd </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reverse iterator pointing to the elem after last (const). </p>
<dl class="section return"><dt>Returns</dt><dd>CConstReverseIterator iterator </dd></dl>

</div>
</div>
<a id="addfd624b66342be573447b93a3e139f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#addfd624b66342be573447b93a3e139f7">&#9670;&nbsp;</a></span>crbegin()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_common_1_1_t_vector.html#a620ba915fe6601254e82360781ac8cd3">CConstReverseIterator</a> <a class="el" href="class_common_1_1_t_vector.html">Common::TVector</a>&lt; T &gt;::crbegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="class_common_1_1_t_vector.html#adcdafcdc204ab13361c046b4079d58a5" title="Reverse iterator pointing to the first elem (const).">ConstReverseBegin()</a> alias (for compatibity) </p>

</div>
</div>
<a id="a0de015e10f1db89a438084121c75e33f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0de015e10f1db89a438084121c75e33f">&#9670;&nbsp;</a></span>crend()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_common_1_1_t_vector.html#a620ba915fe6601254e82360781ac8cd3">CConstReverseIterator</a> <a class="el" href="class_common_1_1_t_vector.html">Common::TVector</a>&lt; T &gt;::crend </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="class_common_1_1_t_vector.html#af50fcd9bee3c5ecb912d4bac5f77462d" title="Reverse iterator pointing to the elem after last (const).">ConstReverseEnd()</a> alias (for compatibity) </p>

</div>
</div>
<a id="ae6f082451d8a03611bfb5c627155ed31"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6f082451d8a03611bfb5c627155ed31">&#9670;&nbsp;</a></span>End()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_common_1_1_t_vector.html#a652c25a5143b2494732a42f6cf84c968">CIterator</a> <a class="el" href="class_common_1_1_t_vector.html">Common::TVector</a>&lt; T &gt;::End </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Iterator pointing to the elem after last. </p>
<dl class="section return"><dt>Returns</dt><dd>CIterator iterator </dd></dl>

</div>
</div>
<a id="a1a008d5b2b5d7bbc4e4a5ccea077bc71"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a008d5b2b5d7bbc4e4a5ccea077bc71">&#9670;&nbsp;</a></span>end() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_common_1_1_t_vector.html#a652c25a5143b2494732a42f6cf84c968">CIterator</a> <a class="el" href="class_common_1_1_t_vector.html">Common::TVector</a>&lt; T &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="class_common_1_1_t_vector.html#ae6f082451d8a03611bfb5c627155ed31" title="Iterator pointing to the elem after last.">End()</a> alias (for compatibity) </p>

</div>
</div>
<a id="abd5e2129f351d6102bf4987ec1e2971e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd5e2129f351d6102bf4987ec1e2971e">&#9670;&nbsp;</a></span>end() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_common_1_1_t_vector.html#ae0cbcdf3adbfe67697fdf44d86e6f24d">CConstIterator</a> <a class="el" href="class_common_1_1_t_vector.html">Common::TVector</a>&lt; T &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="class_common_1_1_t_vector.html#a2424af5eaa1d4c38c5df07466c37b2bb" title="Iterator pointing to the elem after last (const).">ConstEnd()</a> alias (overloaded, for compatibity) </p>

</div>
</div>
<a id="a2726e32a3100881be46a26f33f0a77f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2726e32a3100881be46a26f33f0a77f0">&#9670;&nbsp;</a></span>Erase()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_common_1_1_t_vector.html">Common::TVector</a>&lt; T &gt;::Erase </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>Position</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bAllowAutoShrink</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes element with specified position. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Position</td><td>Position of element to be removed </td></tr>
    <tr><td class="paramname">bAllowAutoShrink</td><td>Enables auto shrink according to the capacity rule. See: EReservedCapacityRule </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>If Position is greater than max index, does nothing. </dd></dl>
<dl class="section attention"><dt>Attention</dt><dd>This method removes one element. To remove multiple, use <a class="el" href="class_common_1_1_t_vector.html#aa5fec059588a4ce275c5a02ad8a8135d" title="Removes range of elements from vector.">EraseMultiple()</a>. Your code with such a mistake will be compiled because of optional bool param. </dd></dl>

</div>
</div>
<a id="aa5fec059588a4ce275c5a02ad8a8135d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5fec059588a4ce275c5a02ad8a8135d">&#9670;&nbsp;</a></span>EraseMultiple()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_common_1_1_t_vector.html">Common::TVector</a>&lt; T &gt;::EraseMultiple </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>PositionFrom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>PositionTo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bAllowAutoShrink</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes range of elements from vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">PositionFrom</td><td>Starting index for erase </td></tr>
    <tr><td class="paramname">PositionTo</td><td>End point for erase. Element with this index will also be removed </td></tr>
    <tr><td class="paramname">bAllowAutoShrink</td><td>Optional. Enables auto shrink according to the capacity rule. See: EReservedCapacityRule </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Ignores elements at unavailable positions. </dd></dl>
<dl class="section attention"><dt>Attention</dt><dd>This method removes multiple elements. To remove one, use <a class="el" href="class_common_1_1_t_vector.html#a2726e32a3100881be46a26f33f0a77f0" title="Removes element with specified position.">Erase()</a>. Your code with such a mistake will be compiled because of optional bool param. </dd></dl>

</div>
</div>
<a id="a5c58ce64e0c1556c4cbb008ce477ce6e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c58ce64e0c1556c4cbb008ce477ce6e">&#9670;&nbsp;</a></span>Front() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T&amp; <a class="el" href="class_common_1_1_t_vector.html">Common::TVector</a>&lt; T &gt;::Front </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Provides access to the first element. </p>
<dl class="section return"><dt>Returns</dt><dd>Reference to the first element </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Vector must not be empty. </dd></dl>

</div>
</div>
<a id="a5a17a4d52a156ba905fa6c03e413e245"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a17a4d52a156ba905fa6c03e413e245">&#9670;&nbsp;</a></span>Front() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const T&amp; <a class="el" href="class_common_1_1_t_vector.html">Common::TVector</a>&lt; T &gt;::Front </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="class_common_1_1_t_vector.html#a5c58ce64e0c1556c4cbb008ce477ce6e" title="Provides access to the first element.">Front()</a> for const vectors. </p>

</div>
</div>
<a id="a9d93c3a7bd6c62d556020e93fc0e0fae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d93c3a7bd6c62d556020e93fc0e0fae">&#9670;&nbsp;</a></span>GetCapacity()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="class_common_1_1_t_vector.html">Common::TVector</a>&lt; T &gt;::GetCapacity </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Capacity is Size + reserved space for the future use. </p>
<dl class="section return"><dt>Returns</dt><dd>Capacity of vector </dd></dl>

</div>
</div>
<a id="afde279a09ddc6246c2455f7e1c8df7fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afde279a09ddc6246c2455f7e1c8df7fd">&#9670;&nbsp;</a></span>GetCapacityRule()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_common_1_1_t_vector.html#a519da74235c0cc6e30868e3aaf24f1d9">EReservedCapacityRule</a> <a class="el" href="class_common_1_1_t_vector.html">Common::TVector</a>&lt; T &gt;::GetCapacityRule </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns Capacity rule that is currently applied. It affects how elements are allocated &amp; destructed. </p>
<dl class="section return"><dt>Returns</dt><dd>EReservedCapacityRule Current capacity rule </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_common_1_1_t_vector.html#a519da74235c0cc6e30868e3aaf24f1d9" title="Used to define how methods deal with Capacity.">EReservedCapacityRule</a> for more info about presets. </dd></dl>

</div>
</div>
<a id="ab369d828bdc8322133940541b4f9c9f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab369d828bdc8322133940541b4f9c9f8">&#9670;&nbsp;</a></span>GetSize()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="class_common_1_1_t_vector.html">Common::TVector</a>&lt; T &gt;::GetSize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Size is number of elements that you can use. </p>
<dl class="section return"><dt>Returns</dt><dd>Size of vector </dd></dl>

</div>
</div>
<a id="ac35a22dbbb3f0c012756936f197e46f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac35a22dbbb3f0c012756936f197e46f0">&#9670;&nbsp;</a></span>Insert() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_common_1_1_t_vector.html">Common::TVector</a>&lt; T &gt;::Insert </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>Position</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>Value</em> = <code>T{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>FillOnResizeWith</em> = <code>T{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Inserts one elements to the specified position. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Position</td><td>Index where to insert </td></tr>
    <tr><td class="paramname">Value</td><td>Value to insert </td></tr>
    <tr><td class="paramname">FillOnResizeWith</td><td>If position is larger than vector size, elements that appear on resize will be initialized with this value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>If Position is greater than max index, vector is resized. </dd></dl>

</div>
</div>
<a id="a127c071eb5ab242598cfbf4752327718"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a127c071eb5ab242598cfbf4752327718">&#9670;&nbsp;</a></span>Insert() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<div class="memtemplate">
template&lt;typename IteratorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_common_1_1_t_vector.html">Common::TVector</a>&lt; T &gt;::Insert </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>Position</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IteratorType&#160;</td>
          <td class="paramname"><em>Begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IteratorType&#160;</td>
          <td class="paramname"><em>End</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>FillOnResizeWith</em> = <code>T{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename std::enable_if&lt;!std::is_integral&lt; IteratorType &gt;::value &gt;::type *&#160;</td>
          <td class="paramname"> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Inserts range of elements, starting at Position. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">IteratorType</td><td>Iterator with implemented ++, != and * </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Position</td><td>Index of the first inserted element </td></tr>
    <tr><td class="paramname">Begin</td><td>Iterator referring to the first element </td></tr>
    <tr><td class="paramname">End</td><td>Iterator referring to the element after last one </td></tr>
    <tr><td class="paramname">FillOnResizeWith</td><td>If position is larger than vector size, elements that appear on resize will be initialized with this value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>If Position is greater than max index, vector is resized. </dd></dl>

</div>
</div>
<a id="ae50f2b9986d95285fb1827e60c0a039b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae50f2b9986d95285fb1827e60c0a039b">&#9670;&nbsp;</a></span>IsEmpty()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="class_common_1_1_t_vector.html">Common::TVector</a>&lt; T &gt;::IsEmpty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Simple check if size of this vector equals 0. </p>
<dl class="section return"><dt>Returns</dt><dd>True if empty, false if not </dd></dl>

</div>
</div>
<a id="a551eae84407bf7dc0330518e5058978d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a551eae84407bf7dc0330518e5058978d">&#9670;&nbsp;</a></span>operator!=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="class_common_1_1_t_vector.html">Common::TVector</a>&lt; T &gt;::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_common_1_1_t_vector.html">TVector</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>Other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Opposite to operator ==. </p>

</div>
</div>
<a id="ae3630a743579413731bc45f6f8a05725"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3630a743579413731bc45f6f8a05725">&#9670;&nbsp;</a></span>operator=() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_common_1_1_t_vector.html">TVector</a>&lt;T&gt;&amp; <a class="el" href="class_common_1_1_t_vector.html">Common::TVector</a>&lt; T &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const std::initializer_list&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>ValuesList</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allows assignment with = {...} style. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ValuesList</td><td>Initializer list </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to this vector </dd></dl>

</div>
</div>
<a id="a5fad32a50ab9a0c26b41e154d3208485"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5fad32a50ab9a0c26b41e154d3208485">&#9670;&nbsp;</a></span>operator=() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_common_1_1_t_vector.html">TVector</a>&lt;T&gt;&amp; <a class="el" href="class_common_1_1_t_vector.html">Common::TVector</a>&lt; T &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_common_1_1_t_vector.html">TVector</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>Other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Assingment operator makes a copy of another vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Other</td><td>vector </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to this vector </dd></dl>

</div>
</div>
<a id="a3f809bf06b1b274497beb336b23ecc90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f809bf06b1b274497beb336b23ecc90">&#9670;&nbsp;</a></span>operator=() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_common_1_1_t_vector.html">TVector</a>&lt;T&gt;&amp; <a class="el" href="class_common_1_1_t_vector.html">Common::TVector</a>&lt; T &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_common_1_1_t_vector.html">TVector</a>&lt; T &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>Other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move assignment. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Other</td><td>Temporary object to get data from </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to this vector </dd></dl>

</div>
</div>
<a id="a948e7a6fcb269ec2fee9ea6f2476ef83"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a948e7a6fcb269ec2fee9ea6f2476ef83">&#9670;&nbsp;</a></span>operator==()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="class_common_1_1_t_vector.html">Common::TVector</a>&lt; T &gt;::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_common_1_1_t_vector.html">TVector</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>Other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if two vectors contain the same values by calling equality operator recursively. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Other</td><td>Other vector to compare </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if sizes and values are equal, false otherwise </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Containing elements must implement == operator </dd></dl>

</div>
</div>
<a id="a72d27069bd4c75b8d8c400f50f3f8c1d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72d27069bd4c75b8d8c400f50f3f8c1d">&#9670;&nbsp;</a></span>operator[]() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T&amp; <a class="el" href="class_common_1_1_t_vector.html">Common::TVector</a>&lt; T &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>Index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Index operator that prodives access to the element. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Index</td><td>aka offset value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to the requested element </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Element with requested index must exist in vector. </dd></dl>

</div>
</div>
<a id="a998e017cc2ebf5ec5da75ecada4f1768"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a998e017cc2ebf5ec5da75ecada4f1768">&#9670;&nbsp;</a></span>operator[]() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const T&amp; <a class="el" href="class_common_1_1_t_vector.html">Common::TVector</a>&lt; T &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>Index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Index operator for const vectors. </p>

</div>
</div>
<a id="a07d3006c13efa25dc0abf1d1f55d1092"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07d3006c13efa25dc0abf1d1f55d1092">&#9670;&nbsp;</a></span>Pop()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T <a class="el" href="class_common_1_1_t_vector.html">Common::TVector</a>&lt; T &gt;::Pop </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bAllowAutoShrink</em> = <code>false</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes one element from the end of vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bAllowAutoShrink</td><td>Optional. Enables auto shrink according to the capacity rule. See: EReservedCapacityRule </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Removed element (by value) </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Vector must not be empty. </dd></dl>

</div>
</div>
<a id="a80d2a825549568315b2f2f8c00bd5a29"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80d2a825549568315b2f2f8c00bd5a29">&#9670;&nbsp;</a></span>PopMultiple()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_common_1_1_t_vector.html">Common::TVector</a>&lt; T &gt;::PopMultiple </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>ElementsCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bAllowAutoShrink</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes N elements from the end of vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ElementsCount</td><td>Number of elements to be removed </td></tr>
    <tr><td class="paramname">bAllowAutoShrink</td><td>Optional. Enables auto shrink according to the capacity rule. See: EReservedCapacityRule </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>If ElementsCount &gt;= Size, clears vector </dd></dl>

</div>
</div>
<a id="ab7f2d52c3264a6351839beee7d9041dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7f2d52c3264a6351839beee7d9041dc">&#9670;&nbsp;</a></span>Push() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_common_1_1_t_vector.html">Common::TVector</a>&lt; T &gt;::Push </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>Value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds one element to the end of vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Value</td><td>Element to add </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>Call <a class="el" href="class_common_1_1_t_vector.html#aa8787ec26793a93cb9f1dfe3da108a21" title="Clears memory that was reserved for future use.">ShrinkToFit()</a> to clear reserved memory, <a class="el" href="class_common_1_1_t_vector.html#aa4ce7e570833e9f5b6ed8a87529e7acb" title="Allocates elements internally for the future use.">Reserve()</a> to increase it </dd></dl>

</div>
</div>
<a id="a024b2f76d062f2ead120fd60c55d7d86"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a024b2f76d062f2ead120fd60c55d7d86">&#9670;&nbsp;</a></span>Push() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<div class="memtemplate">
template&lt;typename IteratorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_common_1_1_t_vector.html">Common::TVector</a>&lt; T &gt;::Push </td>
          <td>(</td>
          <td class="paramtype">IteratorType&#160;</td>
          <td class="paramname"><em>Begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IteratorType&#160;</td>
          <td class="paramname"><em>End</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds elements to the end, uses iterators. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">IteratorType</td><td>Iterator with implemented ++, != and * </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Begin</td><td>Iterator referring to the first element </td></tr>
    <tr><td class="paramname">End</td><td>Iterator referring to the element after last one </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a27b784a5b7c673dcb72593df1efa0564"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a27b784a5b7c673dcb72593df1efa0564">&#9670;&nbsp;</a></span>RawData() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const T* <a class="el" href="class_common_1_1_t_vector.html">Common::TVector</a>&lt; T &gt;::RawData </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="class_common_1_1_t_vector.html#aefa7ae2e67ba665cbb09f3f100d0a8f2" title="Provides access to the internal buffer.">RawData()</a> for const vectors. </p>

</div>
</div>
<a id="aefa7ae2e67ba665cbb09f3f100d0a8f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aefa7ae2e67ba665cbb09f3f100d0a8f2">&#9670;&nbsp;</a></span>RawData() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T* <a class="el" href="class_common_1_1_t_vector.html">Common::TVector</a>&lt; T &gt;::RawData </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Provides access to the internal buffer. </p>
<dl class="section return"><dt>Returns</dt><dd>Pointer to c-style heap array </dd></dl>

</div>
</div>
<a id="a099e402047ded53305319675e93f442c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a099e402047ded53305319675e93f442c">&#9670;&nbsp;</a></span>rbegin() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_common_1_1_t_vector.html#abc0c21b3e1404bbbc0ea2f4d44020b5d">CReverseIterator</a> <a class="el" href="class_common_1_1_t_vector.html">Common::TVector</a>&lt; T &gt;::rbegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="class_common_1_1_t_vector.html#aeb2b0f6f89ddf9207afdc82b9e016fd3" title="Reverse iterator pointing to the first elem.">ReverseBegin()</a> alias (for compatibity) </p>

</div>
</div>
<a id="a78b186c7438610a815abf110f3eb0bde"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78b186c7438610a815abf110f3eb0bde">&#9670;&nbsp;</a></span>rbegin() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_common_1_1_t_vector.html#a620ba915fe6601254e82360781ac8cd3">CConstReverseIterator</a> <a class="el" href="class_common_1_1_t_vector.html">Common::TVector</a>&lt; T &gt;::rbegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="class_common_1_1_t_vector.html#adcdafcdc204ab13361c046b4079d58a5" title="Reverse iterator pointing to the first elem (const).">ConstReverseBegin()</a> alias (overloaded, for compatibity) </p>

</div>
</div>
<a id="a93ce41ca7234c18d7fcaf583cd2e0a36"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93ce41ca7234c18d7fcaf583cd2e0a36">&#9670;&nbsp;</a></span>rend() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_common_1_1_t_vector.html#abc0c21b3e1404bbbc0ea2f4d44020b5d">CReverseIterator</a> <a class="el" href="class_common_1_1_t_vector.html">Common::TVector</a>&lt; T &gt;::rend </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="class_common_1_1_t_vector.html#a235eac07ed0051f720efdaac7b7a6f9f" title="Reverse iterator pointing to the elem after last.">ReverseEnd()</a> alias (for compatibity) </p>

</div>
</div>
<a id="ac831612b2da9aefedeac345112b603ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac831612b2da9aefedeac345112b603ac">&#9670;&nbsp;</a></span>rend() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_common_1_1_t_vector.html#a620ba915fe6601254e82360781ac8cd3">CConstReverseIterator</a> <a class="el" href="class_common_1_1_t_vector.html">Common::TVector</a>&lt; T &gt;::rend </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="class_common_1_1_t_vector.html#af50fcd9bee3c5ecb912d4bac5f77462d" title="Reverse iterator pointing to the elem after last (const).">ConstReverseEnd()</a> alias (overloaded, for compatibity) </p>

</div>
</div>
<a id="aa4ce7e570833e9f5b6ed8a87529e7acb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4ce7e570833e9f5b6ed8a87529e7acb">&#9670;&nbsp;</a></span>Reserve()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_common_1_1_t_vector.html">Common::TVector</a>&lt; T &gt;::Reserve </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>NewCapacity</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocates elements internally for the future use. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">NewCapacity</td><td>If greater than size, will update internal capacity </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>Call <a class="el" href="class_common_1_1_t_vector.html#aa8787ec26793a93cb9f1dfe3da108a21" title="Clears memory that was reserved for future use.">ShrinkToFit()</a> to clear reserved memory. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Passing bAllowAutoShrink to methods may cause shrink. </dd></dl>

</div>
</div>
<a id="a60f6c69c7451b622aca89e24cf81ec61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60f6c69c7451b622aca89e24cf81ec61">&#9670;&nbsp;</a></span>Resize()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_common_1_1_t_vector.html">Common::TVector</a>&lt; T &gt;::Resize </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>NewSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>DefaultValue</em> = <code>{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bAllowAutoShrink</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Changes size of vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">NewSize</td><td>New size of vector. If NewSize &lt; Size, deletes last elements. Otherwise, creates new with passed value. </td></tr>
    <tr><td class="paramname">DefaultValue</td><td>Optional. Value to initialize added elements </td></tr>
    <tr><td class="paramname">bAllowAutoShrink</td><td>Optional. Enables auto shrink according to the capacity rule. See: EReservedCapacityRule </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aeb2b0f6f89ddf9207afdc82b9e016fd3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb2b0f6f89ddf9207afdc82b9e016fd3">&#9670;&nbsp;</a></span>ReverseBegin()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_common_1_1_t_vector.html#abc0c21b3e1404bbbc0ea2f4d44020b5d">CReverseIterator</a> <a class="el" href="class_common_1_1_t_vector.html">Common::TVector</a>&lt; T &gt;::ReverseBegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reverse iterator pointing to the first elem. </p>
<dl class="section return"><dt>Returns</dt><dd>CReverseIterator iterator </dd></dl>

</div>
</div>
<a id="a235eac07ed0051f720efdaac7b7a6f9f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a235eac07ed0051f720efdaac7b7a6f9f">&#9670;&nbsp;</a></span>ReverseEnd()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_common_1_1_t_vector.html#abc0c21b3e1404bbbc0ea2f4d44020b5d">CReverseIterator</a> <a class="el" href="class_common_1_1_t_vector.html">Common::TVector</a>&lt; T &gt;::ReverseEnd </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reverse iterator pointing to the elem after last. </p>
<dl class="section return"><dt>Returns</dt><dd>CReverseIterator iterator </dd></dl>

</div>
</div>
<a id="a56dc9af2d256198d8df92154adbda4ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a56dc9af2d256198d8df92154adbda4ea">&#9670;&nbsp;</a></span>SafeAt() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T&amp; <a class="el" href="class_common_1_1_t_vector.html">Common::TVector</a>&lt; T &gt;::SafeAt </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>Index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>[] with range check. </p>

</div>
</div>
<a id="a0a1784efec9a7c23eee1c024c3b73f18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a1784efec9a7c23eee1c024c3b73f18">&#9670;&nbsp;</a></span>SafeAt() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const T&amp; <a class="el" href="class_common_1_1_t_vector.html">Common::TVector</a>&lt; T &gt;::SafeAt </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>Index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="adcde95defa55d50bbd2aa889fc0632ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adcde95defa55d50bbd2aa889fc0632ad">&#9670;&nbsp;</a></span>SafeBack() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T&amp; <a class="el" href="class_common_1_1_t_vector.html">Common::TVector</a>&lt; T &gt;::SafeBack </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="class_common_1_1_t_vector.html#a79ad5cf5cabca33285e267595700edbb" title="Provides access to the last element.">Back()</a> with range check. </p>

</div>
</div>
<a id="acf25672d9a2be8530f3d59536a8cc55a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf25672d9a2be8530f3d59536a8cc55a">&#9670;&nbsp;</a></span>SafeBack() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const T&amp; <a class="el" href="class_common_1_1_t_vector.html">Common::TVector</a>&lt; T &gt;::SafeBack </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="class_common_1_1_t_vector.html#adcde95defa55d50bbd2aa889fc0632ad" title="Back() with range check.">SafeBack()</a> for const vectors. </p>

</div>
</div>
<a id="ac99e39a82ba80e52d5d32000b679ef3d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac99e39a82ba80e52d5d32000b679ef3d">&#9670;&nbsp;</a></span>SafeBegin()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_common_1_1_t_vector.html#ab3a5ce0edf70da5e5d94bbc280f140cb">CSafeIterator</a> <a class="el" href="class_common_1_1_t_vector.html">Common::TVector</a>&lt; T &gt;::SafeBegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Safe iterator pointing to the first elem. </p>
<dl class="section return"><dt>Returns</dt><dd>CSafeIterator iterator </dd></dl>

</div>
</div>
<a id="ab0376e0a629ec7afa97bcbcb274db1e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0376e0a629ec7afa97bcbcb274db1e0">&#9670;&nbsp;</a></span>SafeConstBegin()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_common_1_1_t_vector.html#a87927820350f8bc80ac7ad41cc97753a">CSafeConstIterator</a> <a class="el" href="class_common_1_1_t_vector.html">Common::TVector</a>&lt; T &gt;::SafeConstBegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Safe iterator pointing to the first elem (const). </p>
<dl class="section return"><dt>Returns</dt><dd>CSafeConstIterator iterator </dd></dl>

</div>
</div>
<a id="a6eca58c21a6dcf351198541e9d062785"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6eca58c21a6dcf351198541e9d062785">&#9670;&nbsp;</a></span>SafeConstEnd()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_common_1_1_t_vector.html#a87927820350f8bc80ac7ad41cc97753a">CSafeConstIterator</a> <a class="el" href="class_common_1_1_t_vector.html">Common::TVector</a>&lt; T &gt;::SafeConstEnd </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Safe iterator pointing to the elem after last (const). </p>
<dl class="section return"><dt>Returns</dt><dd>CSafeConstIterator iterator </dd></dl>

</div>
</div>
<a id="a7867f17103c8ad7c97c1a02d1e91ae93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7867f17103c8ad7c97c1a02d1e91ae93">&#9670;&nbsp;</a></span>SafeConstReverseBegin()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_common_1_1_t_vector.html#a903eca6362843ebacffd6b63ae85b5db">CSafeConstReverseIterator</a> <a class="el" href="class_common_1_1_t_vector.html">Common::TVector</a>&lt; T &gt;::SafeConstReverseBegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Safe reverse iterator pointing to the first elem (const). </p>
<dl class="section return"><dt>Returns</dt><dd>CSafeConstReverseIterator </dd></dl>

</div>
</div>
<a id="adb49407670de6b064203103198c25fb1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb49407670de6b064203103198c25fb1">&#9670;&nbsp;</a></span>SafeConstReverseEnd()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_common_1_1_t_vector.html#a903eca6362843ebacffd6b63ae85b5db">CSafeConstReverseIterator</a> <a class="el" href="class_common_1_1_t_vector.html">Common::TVector</a>&lt; T &gt;::SafeConstReverseEnd </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Safe reverse it. pointing to elem after last (const). </p>
<dl class="section return"><dt>Returns</dt><dd>CSafeConstReverseIterator </dd></dl>

</div>
</div>
<a id="acb4f534420bd80b50faeba5dfc7b4195"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb4f534420bd80b50faeba5dfc7b4195">&#9670;&nbsp;</a></span>SafeEnd()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_common_1_1_t_vector.html#ab3a5ce0edf70da5e5d94bbc280f140cb">CSafeIterator</a> <a class="el" href="class_common_1_1_t_vector.html">Common::TVector</a>&lt; T &gt;::SafeEnd </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Safe iterator pointing to the elem after last. </p>
<dl class="section return"><dt>Returns</dt><dd>CSafeIterator iterator </dd></dl>

</div>
</div>
<a id="a038ce8266736da3ea9999be8c7d388ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a038ce8266736da3ea9999be8c7d388ca">&#9670;&nbsp;</a></span>SafeFront() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T&amp; <a class="el" href="class_common_1_1_t_vector.html">Common::TVector</a>&lt; T &gt;::SafeFront </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="class_common_1_1_t_vector.html#a5c58ce64e0c1556c4cbb008ce477ce6e" title="Provides access to the first element.">Front()</a> with range check. </p>

</div>
</div>
<a id="a9edc2a3851d07627f333c4ff1d5f9aa7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9edc2a3851d07627f333c4ff1d5f9aa7">&#9670;&nbsp;</a></span>SafeFront() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const T&amp; <a class="el" href="class_common_1_1_t_vector.html">Common::TVector</a>&lt; T &gt;::SafeFront </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="class_common_1_1_t_vector.html#a038ce8266736da3ea9999be8c7d388ca" title="Front() with range check.">SafeFront()</a> for const vectors. </p>

</div>
</div>
<a id="a8930b8690ca6ac278b78f44df731cdc6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8930b8690ca6ac278b78f44df731cdc6">&#9670;&nbsp;</a></span>SafePop()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T <a class="el" href="class_common_1_1_t_vector.html">Common::TVector</a>&lt; T &gt;::SafePop </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bAllowAutoShrink</em> = <code>false</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="class_common_1_1_t_vector.html#a07d3006c13efa25dc0abf1d1f55d1092" title="Removes one element from the end of vector.">Pop()</a> with range check. </p>

</div>
</div>
<a id="a7cbc34f370a123b70406dce5c9e4f7f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7cbc34f370a123b70406dce5c9e4f7f0">&#9670;&nbsp;</a></span>SafeReverseBegin()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_common_1_1_t_vector.html#a0344a8c164afdf2d7ba66c07be804f79">CSafeReverseIterator</a> <a class="el" href="class_common_1_1_t_vector.html">Common::TVector</a>&lt; T &gt;::SafeReverseBegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Safe reverse iterator pointing to the first elem. </p>
<dl class="section return"><dt>Returns</dt><dd>CSafeReverseIterator iterator </dd></dl>

</div>
</div>
<a id="a1e75dd85282a98d1001961adece43616"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e75dd85282a98d1001961adece43616">&#9670;&nbsp;</a></span>SafeReverseEnd()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_common_1_1_t_vector.html#a0344a8c164afdf2d7ba66c07be804f79">CSafeReverseIterator</a> <a class="el" href="class_common_1_1_t_vector.html">Common::TVector</a>&lt; T &gt;::SafeReverseEnd </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Safe reverse iterator pointing to the elem after last. </p>
<dl class="section return"><dt>Returns</dt><dd>CSafeReverseIterator iterator </dd></dl>

</div>
</div>
<a id="aba9bb87bd0d8367d341904b90915425c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba9bb87bd0d8367d341904b90915425c">&#9670;&nbsp;</a></span>SafeShift()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T <a class="el" href="class_common_1_1_t_vector.html">Common::TVector</a>&lt; T &gt;::SafeShift </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bAllowAutoShrink</em> = <code>false</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="class_common_1_1_t_vector.html#a6bebae24de311966508f2e60e744987c" title="Removes one element from the beginning of vector.">Shift()</a> with range check. </p>

</div>
</div>
<a id="a49e1cd83803d7579f8e3febbaff17f2b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49e1cd83803d7579f8e3febbaff17f2b">&#9670;&nbsp;</a></span>SetCapacityRule()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_common_1_1_t_vector.html">Common::TVector</a>&lt; T &gt;::SetCapacityRule </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_common_1_1_t_vector.html#a519da74235c0cc6e30868e3aaf24f1d9">EReservedCapacityRule</a>&#160;</td>
          <td class="paramname"><em>CapacityRule</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set enum value that will describe how re-allocation works when elements are added / removed from vertor. Reallocation on removal happens only if bool bAllowAutoShrink was passed with supported operation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">CapacityRule</td><td>Preset value from EReservedCapacityRule </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>If bAllowAutoShrink was passed with operation, size that you have manually reserved may also be deallocated </dd></dl>

</div>
</div>
<a id="a6bebae24de311966508f2e60e744987c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6bebae24de311966508f2e60e744987c">&#9670;&nbsp;</a></span>Shift()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T <a class="el" href="class_common_1_1_t_vector.html">Common::TVector</a>&lt; T &gt;::Shift </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bAllowAutoShrink</em> = <code>false</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes one element from the beginning of vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bAllowAutoShrink</td><td>Optional. Enables auto shrink according to the capacity rule. See: EReservedCapacityRule </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Removed element (by value) </dd></dl>

</div>
</div>
<a id="a5ccce21ef8696b9729eca027b2455a0f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ccce21ef8696b9729eca027b2455a0f">&#9670;&nbsp;</a></span>ShiftMultiple()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_common_1_1_t_vector.html">Common::TVector</a>&lt; T &gt;::ShiftMultiple </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>ElementsCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bAllowAutoShrink</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes N elements from the beginning of vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ElementsCount</td><td>Number of elements to be removed </td></tr>
    <tr><td class="paramname">bAllowAutoShrink</td><td>Enables auto shrink according to the capacity rule. See: EReservedCapacityRule </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>If ElementsCount &gt;= Size, clears vector </dd></dl>

</div>
</div>
<a id="aa8787ec26793a93cb9f1dfe3da108a21"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8787ec26793a93cb9f1dfe3da108a21">&#9670;&nbsp;</a></span>ShrinkToFit()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_common_1_1_t_vector.html">Common::TVector</a>&lt; T &gt;::ShrinkToFit </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clears memory that was reserved for future use. </p>
<dl class="section see"><dt>See also</dt><dd>Methods that can reserve memory: push(), reserve(), etc. </dd></dl>

</div>
</div>
<a id="a1237537b0f430dc5b82043a527185dc3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1237537b0f430dc5b82043a527185dc3">&#9670;&nbsp;</a></span>Swap()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void <a class="el" href="class_common_1_1_t_vector.html">Common::TVector</a>&lt; T &gt;::Swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_common_1_1_t_vector.html">TVector</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>Vector1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_common_1_1_t_vector.html">TVector</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>Vector2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Swaps two vectors internally without deep copy. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Vector1</td><td>First vector </td></tr>
    <tr><td class="paramname">Vector2</td><td>Second vector </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.20-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespace_common.html">Common</a></li><li class="navelem"><a class="el" href="class_common_1_1_t_vector.html">TVector</a></li>
    <li class="footer">Yuri Zamyatin, 2020</li>
  </ul>
</div>
</body>
</html>
